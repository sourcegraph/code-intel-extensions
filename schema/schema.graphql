#! Run this before committing changes to this file
#! go generate github.com/sourcegraph/sourcegraph/cmd/frontend/graphqlbackend
#! This will happen automatically if you are running ./dev/start.sh
#!
#! Lines that begin with #! are treated as internal comments. They are stripped
#! from the schema before the documentation for each field is generated.
#!
#! See docs/api.md for guidance on schema evolution.
#!
schema {
    query: Query
    mutation: Mutation
}

# Represents a null return value.
type EmptyResponse {
    # A dummy null value.
    alwaysNil: String
}

# An object with an ID.
interface Node {
    # The ID of the node.
    id: ID!
}

# A valid JSON value.
scalar JSONValue

# A string that contains valid JSON, with additional support for //-style comments and trailing commas.
scalar JSONCString

# A mutation.
type Mutation {
    # Updates the user profile information for the user with the given ID.
    #
    # Only the user and site admins may perform this mutation.
    updateUser(user: ID!, username: String, displayName: String, avatarURL: String): EmptyResponse!
    # Creates an organization. The caller is added as a member of the newly created organization.
    #
    # Only authenticated users may perform this mutation.
    createOrganization(name: String!, displayName: String): Org!
    # Updates an organization.
    #
    # Only site admins and any member of the organization may perform this mutation.
    updateOrganization(id: ID!, displayName: String): Org!
    # Deletes an organization. Only site admins may perform this mutation.
    deleteOrganization(organization: ID!): EmptyResponse
    # Adds a external service. Only site admins may perform this mutation.
    addExternalService(input: AddExternalServiceInput!): ExternalService!
    # Updates a external service. Only site admins may perform this mutation.
    updateExternalService(input: UpdateExternalServiceInput!): ExternalService!
    # Delete an external service. Only site admins may perform this mutation.
    deleteExternalService(externalService: ID!): EmptyResponse!
    # DEPRECATED: All repositories are accessible or deleted. To prevent a
    # repository from being accessed on Sourcegraph add it to the external
    # service exclude configuration. This mutation will be removed in 3.6.
    #
    # Enables or disables a repository. A disabled repository is only accessible
    # to site admins and never appears in search results.
    #
    # Only site admins may perform this mutation.
    setRepositoryEnabled(repository: ID!, enabled: Boolean!): EmptyResponse
        @deprecated(reason: "update external service exclude setting.")
    # Tests the connection to a mirror repository's original source repository. This is an
    # expensive and slow operation, so it should only be used for interactive diagnostics.
    #
    # Only site admins may perform this mutation.
    checkMirrorRepositoryConnection(
        # The ID of the existing repository whose mirror to check.
        repository: ID
        # The name of a repository whose mirror to check. If the name is provided, the repository need not be added
        # to the site (but the site configuration must define a code host that knows how to handle the name).
        name: String
    ): CheckMirrorRepositoryConnectionResult!
    # Schedule the mirror repository to be updated from its original source repository. Updating
    # occurs automatically, so this should not normally be needed.
    #
    # Only site admins may perform this mutation.
    updateMirrorRepository(
        # The mirror repository to update.
        repository: ID!
    ): EmptyResponse!
    # DEPRECATED: All repositories are scheduled for updates periodically. This
    # mutation will be removed in 3.6.
    #
    # Schedules all repositories to be updated from their original source
    # repositories. Updating occurs automatically, so this should not normally
    # be needed.
    #
    # Only site admins may perform this mutation.
    updateAllMirrorRepositories: EmptyResponse! @deprecated(reason: "syncer ensures all repositories are up to date.")
    # Creates a new user account.
    #
    # Only site admins may perform this mutation.
    createUser(
        # The new user's username.
        username: String!
        # The new user's optional email address. If given, it is marked as verified.
        email: String
    ): CreateUserResult!
    # Randomize a user's password so that they need to reset it before they can sign in again.
    #
    # Only site admins may perform this mutation.
    randomizeUserPassword(user: ID!): RandomizeUserPasswordResult!
    # Adds an email address to the user's account. The email address will be marked as unverified until the user
    # has followed the email verification process.
    #
    # Only the user and site admins may perform this mutation.
    addUserEmail(user: ID!, email: String!): EmptyResponse!
    # Removes an email address from the user's account.
    #
    # Only the user and site admins may perform this mutation.
    removeUserEmail(user: ID!, email: String!): EmptyResponse!
    # Manually set the verification status of a user's email, without going through the normal verification process
    # (of clicking on a link in the email with a verification code).
    #
    # Only site admins may perform this mutation.
    setUserEmailVerified(user: ID!, email: String!, verified: Boolean!): EmptyResponse!
    # Deletes a user account. Only site admins may perform this mutation.
    #
    # If hard == true, a hard delete is performed. By default, deletes are
    # 'soft deletes' and could theoretically be undone with manual DB commands.
    # If a hard delete is performed, the data is truly removed from the
    # database and deletion can NEVER be undone.
    #
    # Data that is deleted as part of this operation:
    #
    # - All user data (access tokens, email addresses, external account info, survey responses, etc)
    # - Organization membership information (which organizations the user is a part of, any invitations created by or targeting the user).
    # - Sourcegraph extensions published by the user.
    # - User, Organization, or Global settings authored by the user.
    #
    deleteUser(user: ID!, hard: Boolean): EmptyResponse
    # Updates the current user's password. The oldPassword arg must match the user's current password.
    updatePassword(oldPassword: String!, newPassword: String!): EmptyResponse
    # Creates an access token that grants the privileges of the specified user (referred to as the access token's
    # "subject" user after token creation). The result is the access token value, which the caller is responsible
    # for storing (it is not accessible by Sourcegraph after creation).
    #
    # The supported scopes are:
    #
    # - "user:all": Full control of all resources accessible to the user account.
    # - "site-admin:sudo": Ability to perform any action as any other user. (Only site admins may create tokens
    #   with this scope.)
    #
    # Only the user or site admins may perform this mutation.
    createAccessToken(user: ID!, scopes: [String!]!, note: String!): CreateAccessTokenResult!
    # Deletes and immediately revokes the specified access token, specified by either its ID or by the token
    # itself.
    #
    # Only site admins or the user who owns the token may perform this mutation.
    deleteAccessToken(byID: ID, byToken: String): EmptyResponse!
    # Deletes the association between an external account and its Sourcegraph user. It does NOT delete the external
    # account on the external service where it resides.
    #
    # Only site admins or the user who is associated with the external account may perform this mutation.
    deleteExternalAccount(externalAccount: ID!): EmptyResponse!
    # Invite the user with the given username to join the organization. The invited user account must already
    # exist.
    #
    # Only site admins and any organization member may perform this mutation.
    inviteUserToOrganization(organization: ID!, username: String!): InviteUserToOrganizationResult!
    # Accept or reject an existing organization invitation.
    #
    # Only the recipient of the invitation may perform this mutation.
    respondToOrganizationInvitation(
        # The organization invitation.
        organizationInvitation: ID!
        # The response to the invitation.
        responseType: OrganizationInvitationResponseType!
    ): EmptyResponse!
    # Resend the notification about an organization invitation to the recipient.
    #
    # Only site admins and any member of the organization may perform this mutation.
    resendOrganizationInvitationNotification(
        # The organization invitation.
        organizationInvitation: ID!
    ): EmptyResponse!
    # Revoke an existing organization invitation.
    #
    # If the invitation has been accepted or rejected, it may no longer be revoked. After an
    # invitation is revoked, the recipient may not accept or reject it. Both cases yield an error.
    #
    # Only site admins and any member of the organization may perform this mutation.
    revokeOrganizationInvitation(
        # The organization invitation.
        organizationInvitation: ID!
    ): EmptyResponse!
    # Immediately add a user as a member to the organization, without sending an invitation email.
    #
    # Only site admins may perform this mutation. Organization members may use the inviteUserToOrganization
    # mutation to invite users.
    addUserToOrganization(organization: ID!, username: String!): EmptyResponse!
    # Removes a user as a member from an organization.
    #
    # Only site admins and any member of the organization may perform this mutation.
    removeUserFromOrganization(user: ID!, organization: ID!): EmptyResponse
    # Adds or removes a tag on a user.
    #
    # Tags are used internally by Sourcegraph as feature flags for experimental features.
    #
    # Only site admins may perform this mutation.
    setTag(
        # The ID of the user whose tags to set.
        #
        # (This parameter is named "node" to make it easy to support tagging other types of nodes
        # other than users in the future.)
        node: ID!
        # The tag to set.
        tag: String!
        # The desired state of the tag on the user (whether to add or remove): true to add, false to
        # remove.
        present: Boolean!
    ): EmptyResponse!
    # Adds a Phabricator repository to Sourcegraph.
    addPhabricatorRepo(
        # The callsign, for example "MUX".
        callsign: String!
        # The name, for example "github.com/gorilla/mux".
        name: String
        # An alias for name. DEPRECATED: use name instead.
        uri: String
        # The URL to the phabricator instance (e.g. http://phabricator.sgdev.org).
        url: String!
    ): EmptyResponse
    # Resolves a revision for a given diff from Phabricator.
    resolvePhabricatorDiff(
        # The name of the repository that the diff is based on.
        repoName: String!
        # The ID of the diff on Phabricator.
        diffID: ID!
        # The base revision this diff is based on.
        baseRev: String!
        # The raw contents of the diff from Phabricator.
        # Required if Sourcegraph doesn't have a Conduit API token.
        patch: String
        # The description of the diff. This will be used as the commit message.
        description: String
        # The name of author of the diff.
        authorName: String
        # The author's email.
        authorEmail: String
        # When the diff was created.
        date: String
    ): GitCommit
    # Logs a user event.
    logUserEvent(event: UserEvent!, userCookieID: String!): EmptyResponse @deprecated(reason: "use logEvent instead")
    # Logs an event.
    logEvent(
        # The name of the event.
        event: String!
        # The randomly generated unique user ID stored in a browser cookie.
        userCookieID: String!
        # The URL when the event was logged.
        url: String!
        # The source of the event.
        source: EventSource!
        # The additional argument information.
        argument: String
    ): EmptyResponse
    # Sends a test notification for the saved search. Be careful: this will send a notifcation (email and other
    # types of notifications, if configured) to all subscribers of the saved search, which could be bothersome.
    #
    # Only subscribers to this saved search may perform this action.
    sendSavedSearchTestNotification(
        # ID of the saved search.
        id: ID!
    ): EmptyResponse
    # All mutations that update settings (global, organization, and user settings) are under this field.
    #
    # Only the settings subject whose settings are being mutated (and site admins) may perform this mutation.
    #
    # This mutation only affects global, organization, and user settings, not site configuration. For site
    # configuration (which is a separate set of configuration properties from global/organization/user settings),
    # use updateSiteConfiguration.
    settingsMutation(input: SettingsMutationGroupInput!): SettingsMutation
    # DEPRECATED: Use settingsMutation instead. This field is a deprecated alias for settingsMutation and will be
    # removed in a future release.
    configurationMutation(input: SettingsMutationGroupInput!): SettingsMutation
        @deprecated(reason: "use settingsMutation instead")
    # Updates the site configuration. Returns whether or not a restart is required for the update to be applied.
    #
    # Only site admins may perform this mutation.
    updateSiteConfiguration(
        # The last ID of the site configuration that is known by the client, to
        # prevent race conditions. An error will be returned if someone else
        # has already written a new update.
        lastID: Int!
        # A JSON object containing the entire site configuration. The previous site configuration will be replaced
        # with this new value.
        input: String!
    ): Boolean!
    # Sets whether the user with the specified user ID is a site admin.
    #
    # Only site admins may perform this mutation.
    #!
    #! 🚨 SECURITY: Only trusted users should be given site admin permissions.
    #! Site admins have full access to the site configuration and other
    #! sensitive data, and they can perform destructive actions such as
    #! restarting the site.
    setUserIsSiteAdmin(userID: ID!, siteAdmin: Boolean!): EmptyResponse
    # Reloads the site by restarting the server. This is not supported for all deployment
    # types. This may cause downtime.
    #
    # Only site admins may perform this mutation.
    reloadSite: EmptyResponse
    # Submits a user satisfaction (NPS) survey.
    submitSurvey(input: SurveySubmissionInput!): EmptyResponse
    # Submits a request for a Sourcegraph Enterprise trial license.
    requestTrial(email: String!): EmptyResponse
    # Manages the extension registry.
    extensionRegistry: ExtensionRegistryMutation!
    # Mutations that are only used on Sourcegraph.com.
    #
    # FOR INTERNAL USE ONLY.
    dotcom: DotcomMutation!
    # Creates a saved search.
    createSavedSearch(
        description: String!
        query: String!
        notifyOwner: Boolean!
        notifySlack: Boolean!
        orgID: ID
        userID: ID
    ): SavedSearch!
    # Updates a saved search
    updateSavedSearch(
        id: ID!
        description: String!
        query: String!
        notifyOwner: Boolean!
        notifySlack: Boolean!
        orgID: ID
        userID: ID
    ): SavedSearch!
    # Deletes a saved search
    deleteSavedSearch(id: ID!): EmptyResponse

    # (experimental) The LSIF API may change substantially in the near future as we
    # continue to adjust it for our use cases. Changes will not be documented in the
    # CHANGELOG during this time.
    # Deletes an LSIF upload.
    deleteLSIFUpload(id: ID!): EmptyResponse

    # (experimental) The LSIF API may change substantially in the near future as we
    # continue to adjust it for our use cases. Changes will not be documented in the
    # CHANGELOG during this time.
    # Deletes an LSIF index.
    deleteLSIFIndex(id: ID!): EmptyResponse

    # Set the permissions of a repository (i.e., which users may view it on Sourcegraph). This
    # operation overwrites the previous permissions for the repository.
    setRepositoryPermissionsForUsers(
        # The repository whose permissions to set.
        repository: ID!
        # A list of user identifiers and their repository permissions, which defines the set of
        # users who may view the repository. All users not included in the list will not be
        # permitted to view the repository on Sourcegraph.
        userPermissions: [UserPermission!]!
    ): EmptyResponse!
    # Schedule a permissions sync for given repository. This queries the repository's code host for
    # all users' permissions associated with the repository, so that the current permissions apply
    # to all users' operations on that repository on Sourcegraph.
    scheduleRepositoryPermissionsSync(repository: ID!): EmptyResponse!
    # Schedule a permissions sync for given user. This queries all code hosts for the user's current
    # repository permissions and syncs them to Sourcegraph, so that the current permissions apply to
    # the user's operations on Sourcegraph.
    scheduleUserPermissionsSync(user: ID!): EmptyResponse!

    #
    # CAMPAIGNS
    #

    # Create a campaign from a campaign spec and locally computed changeset specs. If a campaign in
    # the same namespace with the same name already exists, an error is returned. The newly created
    # campaign is returned.
    createCampaign(
        # The campaign spec that describes the desired state of the campaign.
        campaignSpec: ID!
    ): Campaign!

    # Create or update a campaign from a campaign spec and locally computed changeset specs. If no
    # campaign exists in the namespace with the name given in the campaign spec, a campaign will be
    # created. Otherwise, the existing campaign will be updated. The campaign is returned.
    applyCampaign(
        # The campaign spec that describes the new desired state of the campaign.
        campaignSpec: ID!

        # If set, return an error if the campaign identified using the namespace and campaignSpec
        # parameters does not match the campaign with this ID. This lets callers use a stable ID
        # that refers to a specific campaign during an edit session (and is not susceptible to
        # conflicts if the underlying campaign is moved to a different namespace, renamed, or
        # deleted).
        ensureCampaign: ID
    ): Campaign!

    # Move a campaign to a different namespace, or rename it in the current namespace.
    moveCampaign(campaign: ID!, newName: String, newNamespace: ID): Campaign!

    # Close a campaign.
    closeCampaign(
        campaign: ID!
        # Whether to close the changesets associated with this campaign on their respective code
        # hosts. "Close" means the appropriate final state on the code host (e.g., "closed" on
        # GitHub and "declined" on Bitbucket Server).
        closeChangesets: Boolean = false
    ): Campaign!

    # Delete a campaign. A deleted campaign is completely removed and can't be un-deleted. The
    # campaign's changesets are kept as-is; to close them, use the closeCampaign mutation first.
    deleteCampaign(campaign: ID!): EmptyResponse

    # Upload a changeset spec that will be used in a future update to a campaign. The changeset spec
    # is stored and can be referenced by its ID in the applyCampaign mutation. Just uploading the
    # changeset spec does not result in changes to the campaign or any of its changesets; you need
    # to call applyCampaign to use it.
    #
    # You can use this mutation to upload large changeset specs (e.g., containing large diffs) in
    # individual HTTP requests. Then, in the eventual applyCampaign call, you just refer to the
    # changeset specs by their IDs. This lets you avoid problems when updating large campaigns where
    # a large HTTP request body (e.g., with many large diffs in the changeset specs) would be
    # rejected by the web server/proxy or would be very slow.
    #
    # The returned ChangesetSpec is immutable and expires after a certain period of time (if not
    # used in a call to applyCampaign), which can be queried on ChangesetSpec.expiresAt.
    createChangesetSpec(
        # The raw changeset spec (as JSON).
        changesetSpec: String!
    ): ChangesetSpec!

    # Create a campaign spec that will be used to create a campaign (with the createCampaign
    # mutation), or to update a campaign (with the applyCampaign mutation).
    #
    # The returned CampaignSpec is immutable and expires after a certain period of time (if not used
    # in a call to applyCampaign), which can be queried on CampaignSpec.expiresAt.
    createCampaignSpec(
        # The namespace (either a user or organization). A campaign spec can only be applied to (or
        # used to create) campaigns in this namespace.
        namespace: ID!

        # The campaign spec as YAML (or the equivalent JSON).
        campaignSpec: String!

        # Changeset specs that were locally computed and then uploaded using createChangesetSpec.
        changesetSpecs: [ID!]!
    ): CampaignSpec!

    # Enqueue the given changeset for high-priority syncing.
    syncChangeset(changeset: ID!): EmptyResponse!
}

# The type of the changeset spec.
enum ChangesetSpecType {
    # References an existing changeset on a code host to be imported.
    EXISTING
    # References a branch and a patch to be applied to create the changeset from.
    BRANCH
}

# A changeset spec is an immutable description of the desired state of a changeset in a campaign. To
# create a changeset spec, use the createChangesetSpec mutation.
interface ChangesetSpec {
    # The type of changeset spec.
    type: ChangesetSpecType!

    # The date, if any, when this changeset spec expires and is automatically purged. A changeset
    # spec never expires (and this field is null) if its campaign spec has been applied.
    expiresAt: DateTime
}

# A changeset spec is an immutable description of the desired state of a changeset in a campaign. To
# create a changeset spec, use the createChangesetSpec mutation.
type HiddenChangesetSpec implements ChangesetSpec & Node {
    # The unique ID for a changeset spec.
    #
    # The ID is unguessable (i.e., long and randomly generated, not sequential). This is important
    # even though repository permissions also apply to viewers of changeset specs, because being
    # allowed to view a repository should not entitle a person to view all not-yet-published
    # changesets for that repository. Consider a campaign to fix a security vulnerability: the
    # campaign author may prefer to prepare all of the changesets in private so that the window
    # between revealing the problem and merging the fixes is as short as possible.
    id: ID!

    # The type of changeset spec.
    type: ChangesetSpecType!

    # The date, if any, when this changeset spec expires and is automatically purged. A changeset
    # spec never expires (and this field is null) if its campaign spec has been applied.
    expiresAt: DateTime
}

# A changeset spec is an immutable description of the desired state of a changeset in a campaign. To
# create a changeset spec, use the createChangesetSpec mutation.
type VisibleChangesetSpec implements ChangesetSpec & Node {
    # The unique ID for a changeset spec.
    #
    # The ID is unguessable (i.e., long and randomly generated, not sequential). This is important
    # even though repository permissions also apply to viewers of changeset specs, because being
    # allowed to view a repository should not entitle a person to view all not-yet-published
    # changesets for that repository. Consider a campaign to fix a security vulnerability: the
    # campaign author may prefer to prepare all of the changesets in private so that the window
    # between revealing the problem and merging the fixes is as short as possible.
    id: ID!

    # The type of changeset spec.
    type: ChangesetSpecType!

    # The description of the changeset.
    description: ChangesetDescription!

    # The date, if any, when this changeset spec expires and is automatically purged. A changeset
    # spec never expires (and this field is null) if its campaign spec has been applied.
    expiresAt: DateTime
}

# All possible types of changesets that can be specified in a changeset spec.
union ChangesetDescription = ExistingChangesetReference | GitBranchChangesetDescription

# A reference to a changeset that already exists on a code host (and was not created by the
# campaign).
type ExistingChangesetReference {
    # The repository that contains the existing changeset on the code host.
    baseRepository: Repository!

    # The ID that uniquely identifies the existing changeset on the code host.
    #
    # For GitHub and Bitbucket Server, this is the pull request number (as a string) in the
    # base repository. For example, "1234" for PR #1234.
    externalID: String!
}

# A description of a changeset that represents the proposal to merge one branch into another.
#
# This is used to describe a pull request (on GitHub and Bitbucket Server).
type GitBranchChangesetDescription {
    # The repository that this changeset spec is proposing to change.
    baseRepository: Repository!

    # The full name of the Git ref in the base repository that this changeset is based on (and is
    # proposing to be merged into). This ref must exist on the base repository. For example,
    # "refs/heads/master" or "refs/heads/main".
    baseRef: String!

    # The base revision this changeset is based on. It is the latest commit in
    # baseRef at the time when the changeset spec was created.
    # For example: "4095572721c6234cd72013fd49dff4fb48f0f8a4"
    baseRev: String!

    # The repository that contains the branch with this changeset's changes.
    #
    # Fork repositories and cross-repository changesets are not yet supported. Therefore,
    # headRepository must be equal to baseRepository.
    headRepository: Repository!

    # The full name of the Git ref that holds the changes proposed by this changeset. This ref will
    # be created or updated with the commits. For example, "refs/heads/fix-foo" (for
    # the Git branch "fix-foo").
    headRef: String!

    # The title of the changeset on the code host.
    #
    # On Bitbucket Server or GitHub this is the title of the pull request.
    title: String!

    # The body of the changeset on the code host.
    #
    # On Bitbucket Server or GitHub this is the body/description of the pull request.
    body: String!

    # The Git commits with the proposed changes. These commits are pushed to the head ref.
    #
    # Only 1 commit is supported.
    commits: [GitCommitDescription!]!

    # The total diff of the changeset diff.
    diff: PreviewRepositoryComparison!

    # Whether or not the changeset described here should be created right after
    # applying the ChangesetSpec this description belongs to.
    #
    # If this is false, the changeset will only be created on Sourcegraph and
    # can be previewed.
    #
    # Another ChangesetSpec with the same description, but "published: true",
    # can later be applied publish the changeset.
    published: Boolean!
}

# A description of a Git commit.
#
# TODO: Support specifying committer/author.
type GitCommitDescription {
    # The Git commit message.
    message: String!

    # The commit diff (in unified diff format).
    #
    # The filenames must not be prefixed (e.g., with 'a/' and 'b/'). Tip: use 'git diff --no-prefix'
    # to omit the prefix.
    diff: String!
}

# A list of changeset specs.
type ChangesetSpecConnection {
    # The total number of changeset specs in the connection.
    totalCount: Int!
    # Pagination information.
    pageInfo: PageInfo!
    # A list of changeset specs.
    nodes: [ChangesetSpec!]!
}

# A CampaignDescription describes a campaign.
type CampaignDescription {
    # The name as parsed from the input.
    name: String!

    # The description as parsed from the input.
    description: String!
}

# A campaign spec is an immutable description of the desired state of a campaign. To create a
# campaign spec, use the createCampaignSpec mutation.
type CampaignSpec implements Node {
    # The unique ID for a campaign spec.
    #
    # TODO(sqs): document permissions and ID guessability
    id: ID!

    # The original YAML or JSON input that was used to create this campaign spec.
    originalInput: String!

    # The parsed JSON value of the original input. If the original input was YAML, the YAML is
    # converted to the equivalent JSON.
    parsedInput: JSONValue!

    # The CampaignDescription that describes this campaign.
    description: CampaignDescription!

    # The specs for changesets associated with this campaign.
    changesetSpecs(first: Int, after: String): ChangesetSpecConnection!

    # The user who created this campaign spec (or null if the user no longer exists).
    creator: User

    # The date when this campaign spec was created.
    createdAt: DateTime!

    # The namespace (either a user or organization) of the campaign spec.
    namespace: Namespace

    # The date, if any, when this campaign spec expires and is automatically purged. A campaign spec
    # never expires if it has been applied.
    expiresAt: DateTime

    # The URL of a web page that displays a preview of creating a campaign from this spec.
    previewURL: String!

    # When true, the viewing user can apply this spec.
    viewerCanAdminister: Boolean!
}

# A user (identified either by username or email address) with its repository permission.
input UserPermission {
    # Depending on the bindID option in the permissions.userMapping site configuration property,
    # the elements of the list are either all usernames (bindID of "username") or all email
    # addresses (bindID of "email").
    bindID: String!
    # The highest level of repository permission.
    permission: RepositoryPermission = READ
}

# A campaign is a set of related changes to apply to code across one or more repositories.
type Campaign implements Node {
    # The unique ID for the campaign.
    id: ID!

    # The namespace where this campaign is defined.
    namespace: Namespace!

    # The name of the campaign.
    name: String!

    # The description (as Markdown).
    description: String

    # The branch of the changesets.
    branch: String

    # The user who authored the campaign.
    author: User!

    # Whether the current user can edit or delete this campaign.
    viewerCanAdminister: Boolean!

    # The URL to this campaign.
    url: String!

    # The date and time when the campaign was created.
    createdAt: DateTime!

    # The date and time when the campaign was updated.
    updatedAt: DateTime!

    # The changesets in this campaign that already exist on the code host.
    changesets(
        first: Int
        # Only include changesets with the given state.
        state: ChangesetState
        # Only include changesets with the given external state.
        externalState: ChangesetExternalState
        # Only include changesets with the given review state.
        reviewState: ChangesetReviewState
        # Only include changesets with the given check state.
        checkState: ChangesetCheckState
    ): ChangesetConnection!

    # The changeset counts over time, in 1-day intervals backwards from the point in time given in
    # the "to" parameter.
    changesetCountsOverTime(
        # Only include changeset counts up to this point in time (inclusive). Defaults to Campaign.createdAt.
        from: DateTime
        # Only include changeset counts up to this point in time (inclusive). Defaults to the
        # current time.
        to: DateTime
    ): [ChangesetCounts!]!

    # The date and time when the campaign was closed. If set, applying a spec for this campaign will fail with an error.
    closedAt: DateTime

    # The diff stat for all the changesets in the campaign.
    diffStat: DiffStat!
}

# The counts of changesets in certain states at a specific point in time.
type ChangesetCounts {
    # The point in time these counts were recorded.
    date: DateTime!
    # The total number of changesets.
    total: Int!
    # The number of merged changesets.
    merged: Int!
    # The number of closed changesets.
    closed: Int!
    # The number of open changesets (independent of review state).
    open: Int!
    # The number of changesets that are both open and approved.
    openApproved: Int!
    # The number of changesets that are both open and have requested changes.
    openChangesRequested: Int!
    # The number of changesets that are both open and are pending review.
    openPending: Int!
}

# A list of campaigns.
type CampaignConnection {
    # A list of campaigns.
    nodes: [Campaign!]!

    # The total number of campaigns in the connection.
    totalCount: Int!

    # Pagination information.
    pageInfo: PageInfo!
}

# The internal state of a changeset on Sourcegraph.
enum ChangesetState {
    # The changeset has not yet been created on the code host and is not scheduled to be.
    UNPUBLISHED
    # The changeset is currently being created or updated on the code host.
    PUBLISHING
    # An error occurred while publishing or syncing this changeset.
    ERRORED
    # The changeset is likely up to date and no changes are pending execution.
    SYNCED
}

# The state of a changeset on the code host on which it's hosted.
enum ChangesetExternalState {
    OPEN
    CLOSED
    MERGED
    DELETED
}

# The review state of a changeset.
enum ChangesetReviewState {
    APPROVED
    CHANGES_REQUESTED
    PENDING
    COMMENTED
    DISMISSED
}

# The state of checks (e.g., for continuous integration) on a changeset.
enum ChangesetCheckState {
    PENDING
    PASSED
    FAILED
}

# A label attached to a changeset on a code host.
type ChangesetLabel {
    # The label's text.
    text: String!
    # The label's color, as a hex color code without the #. For example: "93ba13".
    color: String!
    # An optional description of the label.
    description: String
}

# A changeset on a codehost.
interface Changeset {
    # The unique ID for the changeset.
    id: ID!

    # The campaigns that contain this changeset.
    campaigns(
        # Returns the first n campaigns from the list.
        first: Int
        # Only return campaigns in this state.
        state: CampaignState
    ): CampaignConnection!

    # The state of the changeset.
    state: ChangesetState!

    # The external state of the changeset, or null when not yet published to the code host.
    externalState: ChangesetExternalState

    # The date and time when the changeset was created.
    createdAt: DateTime!

    # The date and time when the changeset was updated.
    updatedAt: DateTime!

    # The date and time when the next changeset sync is scheduled, or null if none is scheduled.
    nextSyncAt: DateTime
}

# A changeset on a code host that the user does not have access to.
type HiddenExternalChangeset implements Node & Changeset {
    # The unique ID for the changeset.
    id: ID!

    # The campaigns that contain this changeset.
    campaigns(
        # Returns the first n campaigns from the list.
        first: Int
        # Only return campaigns in this state.
        state: CampaignState
    ): CampaignConnection!

    # The state of the changeset.
    state: ChangesetState!

    # The external state of the changeset, or null when not yet opened.
    externalState: ChangesetExternalState

    # The date and time when the changeset was created.
    createdAt: DateTime!

    # The date and time when the changeset was updated.
    updatedAt: DateTime!

    # The date and time when the next changeset sync is scheduled, or null if none is scheduled.
    nextSyncAt: DateTime
}

# A changeset on a code host (e.g., a pull request on GitHub).
type ExternalChangeset implements Node & Changeset {
    # The unique ID for the changeset.
    id: ID!

    # The external ID that uniquely identifies this ExternalChangeset on the
    # code host. For example, on GitHub this is the pull request number. This is only set once the changeset is published on the code host.
    externalID: String

    # The repository changed by this changeset.
    repository: Repository!

    # The campaigns that contain this changeset.
    campaigns(
        # Returns the first n campaigns from the list.
        first: Int
        # Only return campaigns in this state.
        state: CampaignState
        # Only include campaigns that the viewer can administer.
        viewerCanAdminister: Boolean
    ): CampaignConnection!

    # The events belonging to this changeset.
    events(first: Int): ChangesetEventConnection!

    # The date and time when the changeset was created.
    createdAt: DateTime!

    # The date and time when the changeset was updated.
    updatedAt: DateTime!

    # The date and time when the next changeset sync is scheduled, or null if none is scheduled.
    nextSyncAt: DateTime

    # The title of the changeset.
    title: String!

    # The body of the changeset.
    body: String!

    # The state of the changeset.
    state: ChangesetState!

    # The external state of the changeset, or null when not yet published to the code host.
    externalState: ChangesetExternalState

    # The labels attached to the changeset on the code host.
    labels: [ChangesetLabel!]!

    # The external URL of the changeset on the code host. Not set when changeset state is UNPUBLISHED, PUBLISHING or externalState is DELETED.
    externalURL: ExternalLink

    # The review state of this changeset. This is only set once the changeset is published on the code host.
    reviewState: ChangesetReviewState

    # The base of the diff ("old" or "left-hand side"). It could be null in some cases, for example
    # when a force push has occured.
    base: GitRef

    # The head of the diff ("new" or "right-hand side"). It is common for branches to be deleted
    # after merge in which case head could be null.
    head: GitRef

    # The diff of this changeset, or null if the changeset is closed (without merging) or is already merged.
    diff: RepositoryComparisonInterface

    # The diffstat of this changeset, or null if the changeset is closed
    # (without merging) or is already merged. This data is also available
    # indirectly through the diff field above, but if only the diffStat is
    # required, this field is cheaper to access.
    diffStat: DiffStat

    # The state of the checks (e.g., for continuous integration) on this changeset, or null if no
    # checks have been configured.
    checkState: ChangesetCheckState

    # An error that has occurred when publishing or updating the changeset. This is only set when the changeset state is ERRORED and the viewer can administer this changeset.
    error: String
}

# Used in the campaign page for the overview component.
type ChangesetConnectionStats {
    # The count of unpublished changesets.
    unpublished: Int!
    # The count of externalState: OPEN changesets.
    open: Int!
    # The count of externalState: MERGED changesets.
    merged: Int!
    # The count of externalState: CLOSED changesets.
    closed: Int!
    # The count of all changesets. Equal to totalCount of the connection.
    total: Int!
}

# A list of changesets.
type ChangesetConnection {
    # A list of changesets.
    nodes: [Changeset!]!

    # The total number of changesets in the connection.
    totalCount: Int!

    # Pagination information.
    pageInfo: PageInfo!

    # Stats on all the changesets that are in this connection. Pagination has no effect on the stats.
    stats: ChangesetConnectionStats!
}

# A changeset event in a code host (e.g., a comment on a pull request on GitHub).
type ChangesetEvent implements Node {
    # The unique ID for the changeset event.
    id: ID!

    # The changeset this event belongs to.
    changeset: ExternalChangeset!

    # The date and time when the changeset was created.
    createdAt: DateTime!
}

# A list of changeset events.
type ChangesetEventConnection {
    # A list of changeset events.
    nodes: [ChangesetEvent!]!

    # The total number of changeset events in the connection.
    totalCount: Int!

    # Pagination information.
    pageInfo: PageInfo!
}

# A new external service.
input AddExternalServiceInput {
    # The kind of the external service.
    kind: ExternalServiceKind!
    # The display name of the external service.
    displayName: String!
    # The JSON configuration of the external service.
    config: String!
}

# Fields to update for an existing external service.
input UpdateExternalServiceInput {
    # The id of the external service to update.
    id: ID!
    # The updated display name, if provided.
    displayName: String
    # The updated config, if provided.
    config: String
}

# Describes options for rendering Markdown.
input MarkdownOptions {
    # A dummy null value (empty input types are not allowed yet).
    alwaysNil: String
}

# The product sources where events can come from.
enum EventSource {
    WEB
    CODEHOSTINTEGRATION
    BACKEND
}

# Input for Mutation.settingsMutation, which contains fields that all settings (global, organization, and user
# settings) mutations need.
input SettingsMutationGroupInput {
    # The subject whose settings to mutate (organization, user, etc.).
    subject: ID!
    # The ID of the last-known settings known to the client, or null if there is none. This field is used to
    # prevent race conditions when there are concurrent editors.
    lastID: Int
}

# Mutations that update settings (global, organization, or user settings). These mutations are grouped together
# because they:
#
# - are all versioned to avoid race conditions with concurrent editors
# - all apply to a specific settings subject (i.e., a user, an organization, or the whole site)
#
# Grouping them lets us extract those common parameters to the Mutation.settingsMutation field.
type SettingsMutation {
    # Edit a single property in the settings object.
    editSettings(
        # The edit to apply to the settings.
        edit: SettingsEdit!
    ): UpdateSettingsPayload
    # DEPRECATED
    editConfiguration(edit: ConfigurationEdit!): UpdateSettingsPayload
        @deprecated(
            reason: "Use editSettings instead. This field is a deprecated alias for it and will be removed in a future release."
        )
    # Overwrite the existing settings with the new settings.
    overwriteSettings(
        # A JSON object (stringified) of the settings. Trailing commas and "//"-style comments are supported. The
        # entire previous settings value will be overwritten by this new value.
        contents: String!
    ): UpdateSettingsPayload
}

# An edit to a JSON property in a settings JSON object. The JSON property to edit can be nested.
input SettingsEdit {
    # The key path of the property to update.
    #
    # Inserting into an existing array is not yet supported.
    keyPath: [KeyPathSegment!]!
    # The new JSON-encoded value to insert. If the field's value is not set, the property is removed. (This is
    # different from the field's value being the JSON null value.)
    #
    # When the value is a non-primitive type, it must be specified using a GraphQL variable, not an inline literal,
    # or else the GraphQL parser will return an error.
    value: JSONValue
    # Whether to treat the value as a JSONC-encoded string, which makes it possible to perform an edit that
    # preserves (or adds/removes) comments.
    valueIsJSONCEncodedString: Boolean = false
}

# DEPRECATED: This type was renamed to SettingsEdit.
#
# NOTE: GraphQL does not support @deprecated directives on INPUT_FIELD_DEFINITION (input fields).
input ConfigurationEdit {
    # DEPRECATED
    keyPath: [KeyPathSegment!]!
    # DEPRECATED
    value: JSONValue
    # DEPRECATED
    valueIsJSONCEncodedString: Boolean = false
}

# A segment of a key path that locates a nested JSON value in a root JSON value. Exactly one field in each
# KeyPathSegment must be non-null.
#
# For example, in {"a": [0, {"b": 3}]}, the value 3 is located at the key path ["a", 1, "b"].
input KeyPathSegment {
    # The name of the property in the object at this location to descend into.
    property: String
    # The index of the array at this location to descend into.
    index: Int
}

# The payload for SettingsMutation.updateConfiguration.
type UpdateSettingsPayload {
    # An empty response.
    empty: EmptyResponse
}

# The result for Mutation.createAccessToken.
type CreateAccessTokenResult {
    # The ID of the newly created access token.
    id: ID!
    # The secret token value that is used to authenticate API clients. The caller is responsible for storing this
    # value.
    token: String!
}

# The result for Mutation.checkMirrorRepositoryConnection.
type CheckMirrorRepositoryConnectionResult {
    # The error message encountered during the update operation, if any. If null, then
    # the connection check succeeded.
    error: String
}

# The result for Mutation.createUser.
type CreateUserResult {
    # The new user.
    user: User!
    # The reset password URL that the new user must visit to sign into their account. If the builtin
    # username-password authentication provider is not enabled, this field's value is null.
    resetPasswordURL: String
}

# The result for Mutation.randomizeUserPassword.
type RandomizeUserPasswordResult {
    # The reset password URL that the user must visit to sign into their account again. If the builtin
    # username-password authentication provider is not enabled, this field's value is null.
    resetPasswordURL: String
}

# Input for a user satisfaction (NPS) survey submission.
input SurveySubmissionInput {
    # User-provided email address, if there is no currently authenticated user. If there is, this value
    # will not be used.
    email: String
    # User's likelihood of recommending Sourcegraph to a friend, from 0-10.
    score: Int!
    # The answer to "What is the most important reason for the score you gave".
    reason: String
    # The answer to "What can Sourcegraph do to provide a better product"
    better: String
}

# The state of the campaign
enum CampaignState {
    OPEN
    CLOSED
}

# A query.
type Query {
    # The root of the query.
    root: Query! @deprecated(reason: "this will be removed.")
    # Looks up a node by ID.
    node(id: ID!): Node

    # A list of campaigns.
    campaigns(
        # Returns the first n campaigns from the list.
        first: Int
        state: CampaignState
        # Only include campaigns that the viewer can administer.
        viewerCanAdminister: Boolean
    ): CampaignConnection!

    # Looks up a repository by either name or cloneURL.
    repository(
        # Query the repository by name, for example "github.com/gorilla/mux".
        name: String
        # Query the repository by a Git clone URL (format documented here: https://git-scm.com/docs/git-clone#_git_urls_a_id_urls_a)
        # by checking for a code host configuration that matches the clone URL.
        # Will not actually check the code host to see if the repository actually exists.
        cloneURL: String
        # An alias for name. DEPRECATED: use name instead.
        uri: String
    ): Repository
    # Looks up a repository by either name or cloneURL. When the repository does not exist on the server
    # and "disablePublicRepoRedirects" is "false" in the site configuration, it returns a Redirect to
    # an external Sourcegraph URL that may have this repository instead. Otherwise, this query returns
    # null.
    repositoryRedirect(
        # Query the repository by name, for example "github.com/gorilla/mux".
        name: String
        # Query the repository by a Git clone URL (format documented here: https://git-scm.com/docs/git-clone#_git_urls_a_id_urls_a)
        # by checking for a code host configuration that matches the clone URL.
        # Will not actually check the code host to see if the repository actually exists.
        cloneURL: String
    ): RepositoryRedirect
    # Lists all external services.
    externalServices(
        # Returns the first n external services from the list.
        first: Int
    ): ExternalServiceConnection!
    # List all repositories.
    repositories(
        # Returns the first n repositories from the list.
        first: Int
        # Return repositories whose names match the query.
        query: String
        # Return repositories whose names are in the list.
        names: [String!]
        # Include cloned repositories.
        cloned: Boolean = true
        # Include repositories that are currently being cloned.
        # DEPRECATED: This will be removed.
        cloneInProgress: Boolean = true
        # Include repositories that are not yet cloned and for which cloning is not in progress.
        notCloned: Boolean = true
        # Include repositories that have a text search index.
        indexed: Boolean = true
        # Include repositories that do not have a text search index.
        notIndexed: Boolean = true
        # Sort field.
        orderBy: RepositoryOrderBy = REPOSITORY_NAME
        # Sort direction.
        descending: Boolean = false
    ): RepositoryConnection!
    # Looks up a Phabricator repository by name.
    phabricatorRepo(
        # The name, for example "github.com/gorilla/mux".
        name: String
        # An alias for name. DEPRECATED: use name instead.
        uri: String
    ): PhabricatorRepo
    # The current user.
    currentUser: User
    # Looks up a user by username or email address.
    user(
        # Query the user by username.
        username: String
        # Query the user by verified email address.
        email: String
    ): User
    # List all users.
    users(
        # Returns the first n users from the list.
        first: Int
        # Return users whose usernames or display names match the query.
        query: String
        # Return only users with the given tag.
        tag: String
        # Returns users who have been active in a given period of time.
        activePeriod: UserActivePeriod
    ): UserConnection!
    # Looks up an organization by name.
    organization(name: String!): Org
    # List all organizations.
    organizations(
        # Returns the first n organizations from the list.
        first: Int
        # Return organizations whose names or display names match the query.
        query: String
    ): OrgConnection!
    # Renders Markdown to HTML. The returned HTML is already sanitized and
    # escaped and thus is always safe to render.
    renderMarkdown(markdown: String!, options: MarkdownOptions): String!
    # EXPERIMENTAL: Syntax highlights a code string.
    highlightCode(code: String!, fuzzyLanguage: String!, disableTimeout: Boolean!, isLightTheme: Boolean!): String!
    # Looks up an instance of a type that implements SettingsSubject (i.e., something that has settings). This can
    # be a site (which has global settings), an organization, or a user.
    settingsSubject(id: ID!): SettingsSubject
    # The settings for the viewer. The viewer is either an anonymous visitor (in which case viewer settings is
    # global settings) or an authenticated user (in which case viewer settings are the user's settings).
    viewerSettings: SettingsCascade!
    # DEPRECATED
    viewerConfiguration: ConfigurationCascade! @deprecated(reason: "use viewerSettings instead")
    # The configuration for clients.
    clientConfiguration: ClientConfigurationDetails!
    # Fetch search filter suggestions for autocompletion.
    searchFilterSuggestions: SearchFilterSuggestions!
    # Runs a search.
    search(
        # The version of the search syntax being used.
        # All new clients should use the latest version.
        version: SearchVersion = V1
        # PatternType controls the search pattern type, if and only if it is not specified in the query string using
        # the patternType: field.
        patternType: SearchPatternType
        # The search query (such as "foo" or "repo:myrepo foo").
        query: String = ""

        # (experimental) Optionally specify the versionContext. If not specified the
        # default version context is used (all repositories on the default branch).
        versionContext: String

        # (experimental) Sourcegraph 3.9 added support for cursor-based paginated
        # search requests when this field is specified. For details, see
        # https://docs.sourcegraph.com/api/graphql/search
        #
        # When specified, indicates that this request should be paginated and
        # to fetch results starting at this cursor.
        #
        # A future request can be made for more results by passing in the
        # 'SearchResults.pageInfo.endCursor' that is returned.
        after: String

        # (experimental) Sourcegraph 3.9 added support for cursor-based paginated
        # search requests when this field is specified. For details, see
        # https://docs.sourcegraph.com/api/graphql/search
        #
        # When specified, indicates that this request should be paginated and
        # the first N results (relative to the cursor) should be returned. i.e.
        # how many results to return per page. It must be in the range of 0-5000.
        first: Int
    ): Search
    # All saved searches configured for the current user, merged from all configurations.
    savedSearches: [SavedSearch!]!
    # All repository groups for the current user, merged from all configurations.
    repoGroups: [RepoGroup!]!
    # (experimental) All version contexts.
    versionContexts: [VersionContext!]!
    # (experimental) Return the parse tree of a search query.
    parseSearchQuery(
        # The search query (such as "repo:myrepo foo").
        query: String = ""
        # The parser to use for this query.
        patternType: SearchPatternType = literal
    ): JSONValue
    # The current site.
    site: Site!
    # Retrieve responses to surveys.
    surveyResponses(
        # Returns the first n survey responses from the list.
        first: Int
    ): SurveyResponseConnection!
    # The extension registry.
    extensionRegistry: ExtensionRegistry!
    # Queries that are only used on Sourcegraph.com.
    #
    # FOR INTERNAL USE ONLY.
    dotcom: DotcomQuery!
    # FOR INTERNAL USE ONLY: Lists all status messages
    statusMessages: [StatusMessage!]!

    # Look up a namespace by ID.
    namespace(id: ID!): Namespace

    # The repositories a user is authorized to access with the given permission.
    # This isn’t defined in the User type because we store permissions for users
    # that don’t yet exist (i.e. late binding). Only one of "username" or "email"
    # is required to identify a user.
    authorizedUserRepositories(
        # The username.
        username: String
        # One of the email addresses.
        email: String
        # Permission that the user has on the repositories.
        perm: RepositoryPermission = READ
        # Number of repositories to return after the given cursor.
        first: Int!
        # Opaque pagination cursor.
        after: String
    ): RepositoryConnection!

    # Returns a list of usernames or emails that have associated pending permissions.
    # The returned list can be used to query authorizedUserRepositories for pending permissions.
    usersWithPendingPermissions: [String!]!

    # (experimental) The LSIF API may change substantially in the near future as we
    # continue to adjust it for our use cases. Changes will not be documented in the
    # CHANGELOG during this time.
    # The repository's LSIF uploads.
    lsifUploads(
        # An (optional) search query that searches over the state, repository name,
        # commit, root, and indexer properties.
        query: String

        # The state of returned uploads.
        state: LSIFUploadState

        # When specified, shows only uploads that are latest for the given repository.
        isLatestForRepo: Boolean

        # When specified, indicates that this request should be paginated and
        # the first N results (relative to the cursor) should be returned. i.e.
        # how many results to return per page. It must be in the range of 0-5000.
        first: Int

        # When specified, indicates that this request should be paginated and
        # to fetch results starting at this cursor.
        #
        # A future request can be made for more results by passing in the
        # 'LSIFUploadConnection.pageInfo.endCursor' that is returned.
        after: String
    ): LSIFUploadConnection!

    # (experimental) The LSIF API may change substantially in the near future as we
    # continue to adjust it for our use cases. Changes will not be documented in the
    # CHANGELOG during this time.
    # The repository's LSIF uploads.
    lsifIndexes(
        # An (optional) search query that searches over the state, repository name,
        # and commit properties.
        query: String

        # The state of returned uploads.
        state: LSIFIndexState

        # When specified, indicates that this request should be paginated and
        # the first N results (relative to the cursor) should be returned. i.e.
        # how many results to return per page. It must be in the range of 0-5000.
        first: Int

        # When specified, indicates that this request should be paginated and
        # to fetch results starting at this cursor.
        #
        # A future request can be made for more results by passing in the
        # 'LSIFIndexConnection.pageInfo.endCursor' that is returned.
        after: String
    ): LSIFIndexConnection!
}

# The version of the search syntax.
enum SearchVersion {
    # Search syntax that defaults to regexp search.
    V1
    # Search syntax that defaults to literal search.
    V2
}

# The search pattern type.
enum SearchPatternType {
    literal
    regexp
    structural
}

# Configuration details for the browser extension, editor extensions, etc.
type ClientConfigurationDetails {
    # The list of phabricator/gitlab/bitbucket/etc instance URLs that specifies which pages the content script will be injected into.
    contentScriptUrls: [String!]!
    # Returns details about the parent Sourcegraph instance.
    parentSourcegraph: ParentSourcegraphDetails!
}

# Parent Sourcegraph instance
type ParentSourcegraphDetails {
    # Sourcegraph instance URL.
    url: String!
}

# A search.
type Search {
    # The results.
    results: SearchResults!
    # The suggestions.
    suggestions(first: Int): [SearchSuggestion!]!
    # A subset of results (excluding actual search results) which are heavily
    # cached and thus quicker to query. Useful for e.g. querying sparkline
    # data.
    stats: SearchResultsStats!
}

# Predefined suggestions for search filters when backfill.
type SearchFilterSuggestions {
    # The suggestions for search filter "repogroup:".
    repogroup: [String!]!
    # The suggestions for search filter "repo:".
    repo: [String!]!
}

# A search result.
union SearchResult = FileMatch | CommitSearchResult | Repository | CodemodResult

# An object representing a markdown string.
type Markdown {
    # The raw markdown string.
    text: String!
    # HTML for the rendered markdown string, or null if there is no HTML representation provided.
    # If specified, clients should render this directly.
    html: String!
}

# A search result. Every type of search result, except FileMatch, must implement this interface.
interface GenericSearchResultInterface {
    # URL to an icon that is displayed with every search result.
    icon: String!
    # A markdown string that is rendered prominently.
    label: Markdown!
    # The URL of the result.
    url: String!
    # A markdown string that is rendered less prominently.
    detail: Markdown!
    # A list of matches in this search result.
    matches: [SearchResultMatch!]!
}

# A match in a search result. Matches make up the body content of a search result.
type SearchResultMatch {
    # URL for the individual result match.
    url: String!
    # A markdown string containing the preview contents of the result match.
    body: Markdown!
    # A list of highlights that specify locations of matches of the query in the body. Each highlight is
    # a line number, character offset, and length. Currently, highlights are only displayed on match bodies
    # that are code blocks. If the result body is a code block, exclude the markdown code fence lines in
    # the line and character count. Leave as an empty list if no highlights are available.
    highlights: [Highlight!]!
}

# Search results.
type SearchResults {
    # The results. Inside each SearchResult there may be multiple matches, e.g.
    # a FileMatch may contain multiple line matches.
    results: [SearchResult!]!
    # The total number of matches returned by this search. This is different
    # than the length of the results array in that e.g. a single results array
    # entry may contain multiple matches. For example, the results array may
    # contain two file matches and this field would report 6 ("3 line matches
    # per file") while the length of the results array would report 3
    # ("3 FileMatch results").
    #
    # Typically, 'approximateResultCount', not this field, is shown to users.
    matchCount: Int!
    # DEPRECATED: Renamed to 'matchCount' for less ambiguity.
    resultCount: Int! @deprecated(reason: "renamed to matchCount for less ambiguity")
    # The approximate number of results. This is like the length of the results
    # array, except it can indicate the number of results regardless of whether
    # or not the limit was hit. Currently, this is represented as e.g. "5+"
    # results.
    #
    # This string is typically shown to users to indicate the true result count.
    approximateResultCount: String!
    # Whether or not the results limit was hit.
    #
    # In paginated requests, this field is always false. Use 'pageInfo.hasNextPage' instead.
    limitHit: Boolean!
    # Integers representing the sparkline for the search results.
    sparkline: [Int!]!
    # Repositories that were eligible to be searched.
    repositories: [Repository!]!
    # The number of repositories that were eligible to be searched (for clients
    # that just wish to know how many without querying the, sometimes extremely
    # large, list).
    repositoriesCount: Int!
    # Repositories that were actually searched. Excludes repositories that would have been searched but were not
    # because a timeout or error occurred while performing the search, or because the result limit was already
    # reached, or because they were excluded due to being forks or archives.
    #
    # In paginated search requests, this represents the set of repositories searched for the
    # individual paginated request / input cursor and not the global set of repositories that
    # would be searched if further requests were made.
    repositoriesSearched: [Repository!]!
    # Indexed repositories searched. This is a subset of repositoriesSearched.
    indexedRepositoriesSearched: [Repository!]!
    # Repositories that are busy cloning onto gitserver.
    #
    # In paginated search requests, some repositories may be cloning. These are reported here
    # and you may choose to retry the paginated request with the same cursor after they have
    # cloned OR you may simply continue making further paginated requests and choose to skip
    # the cloning repositories.
    cloning: [Repository!]!
    # Repositories or commits that do not exist.
    #
    # In paginated search requests, some repositories may be missing (e.g. if Sourcegraph is
    # aware of them but is temporarily unable to serve them). These are reported here and you
    # may choose to retry the paginated request with the same cursor and they may no longer be
    # missing OR you may simply continue making further paginated requests and choose to skip
    # the missing repositories.
    missing: [Repository!]!
    # Repositories or commits which we did not manage to search in time. Trying
    # again usually will work.
    #
    # In paginated search requests, this field is not relevant.
    timedout: [Repository!]!
    # True if indexed search is enabled but was not available during this search.
    indexUnavailable: Boolean!
    # An alert message that should be displayed before any results.
    alert: SearchAlert
    # The time it took to generate these results.
    elapsedMilliseconds: Int!
    # Dynamic filters generated by the search results
    dynamicFilters: [SearchFilter!]!
    # Pagination information.
    #
    # This field is only applcable when the original request was a paginated one.
    pageInfo: PageInfo!
}

# Statistics about search results.
type SearchResultsStats {
    # The approximate number of results returned.
    approximateResultCount: String!
    # The sparkline.
    sparkline: [Int!]!

    # Statistics about the languages represented in the search results.
    #
    # Known issue: The LanguageStatistics.totalBytes field values are incorrect in the result.
    languages: [LanguageStatistics!]!
}

# A search filter.
type SearchFilter {
    # The value.
    value: String!
    # The string to be displayed in the UI.
    label: String!
    # Number of matches for a given filter.
    count: Int!
    # Whether the results returned are incomplete.
    limitHit: Boolean!
    # The kind of filter. Should be "file" or "repo".
    kind: String!
}

# A programming language.
type Language {
    # Name of the programming language.
    name: String!
}

# A search suggestion.
union SearchSuggestion = Repository | File | Symbol | Language

# A search-related alert message.
type SearchAlert {
    # The title.
    title: String!
    # The description.
    description: String
    # "Did you mean: ____" query proposals
    proposedQueries: [SearchQueryDescription!]
}

# A saved search query, defined in settings.
type SavedSearch implements Node {
    # The unique ID of this saved query.
    id: ID!
    # The description.
    description: String!
    # The query.
    query: String!
    # Whether or not to notify the owner of the saved search via email. This owner is either
    # a single user, or every member of an organization that owns the saved search.
    notify: Boolean!
    # Whether or not to notify on Slack.
    notifySlack: Boolean!
    # The user or org that owns this saved search.
    namespace: Namespace!
    # The Slack webhook URL associated with this saved search, if any.
    slackWebhookURL: String
}

# A search query description.
type SearchQueryDescription {
    # The description.
    description: String
    # The query.
    query: String!
}

# A group of repositories.
type RepoGroup {
    # The name.
    name: String!
    # The repositories.
    repositories: [String!]!
}

# A diff between two diffable Git objects.
type Diff {
    # The diff's repository.
    repository: Repository!
    # The revision range of the diff.
    range: GitRevisionRange!
}

# A search result that is a Git commit.
type CommitSearchResult implements GenericSearchResultInterface {
    # Base64 data uri to an icon.
    icon: String!
    # A markdown string that is rendered prominently.
    label: Markdown!
    # The URL of the result.
    url: String!
    # A markdown string of that is rendered less prominently.
    detail: Markdown!
    # The result previews of the result.
    matches: [SearchResultMatch!]!
    # The commit that matched the search query.
    commit: GitCommit!
    # The ref names of the commit.
    refs: [GitRef!]!
    # The refs by which this commit was reached.
    sourceRefs: [GitRef!]!
    # The matching portion of the commit message, if any.
    messagePreview: HighlightedString
    # The matching portion of the diff, if any.
    diffPreview: HighlightedString
}

# The result of a code modification query.
type CodemodResult implements GenericSearchResultInterface {
    # URL to an icon that is displayed with every search result.
    icon: String!
    # A markdown string that is rendered prominently.
    label: Markdown!
    # The URL of the result.
    url: String!
    # A markdown string that is rendered less prominently.
    detail: Markdown!
    # A list of matches in this search result.
    matches: [SearchResultMatch!]!
    # The commit whose contents the codemod was run against.
    commit: GitCommit!
    # The raw diff of the modification.
    rawDiff: String!
}

# A search result that is a diff between two diffable Git objects.
type DiffSearchResult {
    # The diff that matched the search query.
    diff: Diff!
    # The matching portion of the diff.
    preview: HighlightedString!
}

# A string that has highlights (e.g, query matches).
type HighlightedString {
    # The full contents of the string.
    value: String!
    # Highlighted matches of the query in the preview string.
    highlights: [Highlight!]!
}

# A highlighted region in a string (e.g., matched by a query).
type Highlight {
    # The 1-indexed line number.
    line: Int!
    # The 1-indexed character on the line.
    character: Int!
    # The length of the highlight, in characters (on the same line).
    length: Int!
}

# A list of external services.
type ExternalServiceConnection {
    # A list of external services.
    nodes: [ExternalService!]!

    # The total number of external services in the connection.
    totalCount: Int!

    # Pagination information.
    pageInfo: PageInfo!
}

# A specific kind of external service.
enum ExternalServiceKind {
    AWSCODECOMMIT
    BITBUCKETCLOUD
    BITBUCKETSERVER
    GITHUB
    GITLAB
    GITOLITE
    PHABRICATOR
    OTHER
}

# A configured external service.
type ExternalService implements Node {
    # The external service's unique ID.
    id: ID!
    # The kind of external service.
    kind: ExternalServiceKind!
    # The display name of the external service.
    displayName: String!
    # The JSON configuration of the external service.
    config: JSONCString!
    # When the external service was created.
    createdAt: DateTime!
    # When the external service was last updated.
    updatedAt: DateTime!
    # An optional URL that will be populated when webhooks have been configured for the external service.
    webhookURL: String
    # This is an optional field that's populated when we ran into errors on the
    # backend side when trying to create/update an ExternalService, but the
    # create/update still succeeded.
    # It is a field on ExternalService instead of a separate thing in order to
    # not break the API and stay backwards compatible.
    warning: String
}

# A list of repositories.
type RepositoryConnection {
    # A list of repositories.
    nodes: [Repository!]!
    # The total count of repositories in the connection. This total count may be larger
    # than the number of nodes in this object when the result is paginated.
    # This requires admin permissions and will return null for all non-admin users.
    #
    # In some cases, the total count can't be computed quickly; if so, it is null. Pass
    # precise: true to always compute total counts even if it takes a while.
    totalCount(precise: Boolean = false): Int
    # Pagination information.
    pageInfo: PageInfo!
}

# A repository is a Git source control repository that is mirrored from some origin code host.
type Repository implements Node & GenericSearchResultInterface {
    # The repository's unique ID.
    id: ID!
    # The repository's name, as a path with one or more components. It conventionally consists of
    # the repository's hostname and path (joined by "/"), minus any suffixes (such as ".git").
    #
    # Examples:
    #
    # - github.com/foo/bar
    # - my-code-host.example.com/myrepo
    # - myrepo
    name: String!
    # DEPRECATED: Use name.
    uri: String! @deprecated(reason: "Use name.")
    # The repository's description.
    description: String!
    # The primary programming language in the repository.
    language: String!
    # DEPRECATED: This field is unused in known clients.
    #
    # The date when this repository was created on Sourcegraph.
    createdAt: DateTime!
    # DEPRECATED: This field is unused in known clients.
    #
    # The date when this repository's metadata was last updated on Sourcegraph.
    updatedAt: DateTime
    # Returns information about the given commit in the repository, or null if no commit exists with the given rev.
    commit(
        # The Git revision specifier (revspec) for the commit.
        rev: String!
        # Optional input revspec used to construct non-canonical URLs and other "friendly" field values. Used by
        # clients that must ensure consistency of revision resolution within a session/request (so they use full
        # SHAs) but also preserve the user input rev (for user friendliness).
        inputRevspec: String
    ): GitCommit
    # Information and status related to mirroring, if this repository is a mirror of another repository (e.g., on
    # some code host). In this case, the remote source repository is external to Sourcegraph and the mirror is
    # maintained by the Sourcegraph site (not the other way around).
    mirrorInfo: MirrorRepositoryInfo!
    # Information about this repository from the external service that it originates from (such as GitHub, GitLab,
    # Phabricator, etc.).
    externalRepository: ExternalRepository!
    # Whether the repository is a fork.
    isFork: Boolean!
    # Whether the repository has been archived.
    isArchived: Boolean!
    # Whether the repository is private.
    isPrivate: Boolean!
    # Lists all external services which yield this repository.
    externalServices(
        # Returns the first n external services from the list.
        first: Int
    ): ExternalServiceConnection!
    # Whether the repository is currently being cloned.
    cloneInProgress: Boolean! @deprecated(reason: "use Repository.mirrorInfo.cloneInProgress instead")
    # Information about the text search index for this repository, or null if text search indexing
    # is not enabled or supported for this repository.
    textSearchIndex: RepositoryTextSearchIndex
    # The URL to this repository.
    url: String!
    # The URLs to this repository on external services associated with it.
    externalURLs: [ExternalLink!]!
    # The repository's default Git branch (HEAD symbolic ref). If the repository is currently being cloned or is
    # empty, this field will be null.
    defaultBranch: GitRef
    # The repository's Git refs.
    gitRefs(
        # Returns the first n Git refs from the list.
        first: Int
        # Return Git refs whose names match the query.
        query: String
        # Return only Git refs of the given type.
        #
        # Known issue: It is only supported to retrieve Git branch and tag refs, not
        # other Git refs.
        type: GitRefType
        # Ordering for Git refs in the list.
        orderBy: GitRefOrder
        # Ordering is an expensive operation that doesn't scale for lots of
        # references. If this is true we fallback on not ordering. This should
        # never be false in interactive API requests.
        interactive: Boolean = true
    ): GitRefConnection!
    # The repository's Git branches.
    branches(
        # Returns the first n Git branches from the list.
        first: Int
        # Return Git branches whose names match the query.
        query: String
        # Ordering for Git branches in the list.
        orderBy: GitRefOrder
        # Ordering is an expensive operation that doesn't scale for lots of
        # references. If this is true we fallback on not ordering. This should
        # never be false in interactive API requests.
        interactive: Boolean = true
    ): GitRefConnection!
    # The repository's Git tags.
    tags(
        # Returns the first n Git tags from the list.
        first: Int
        # Return Git tags whose names match the query.
        query: String
    ): GitRefConnection!
    # A Git comparison in this repository between a base and head commit.
    comparison(
        # The base of the diff ("old" or "left-hand side"), or "HEAD" if not specified.
        base: String
        # The head of the diff ("new" or "right-hand side"), or "HEAD" if not specified.
        head: String
        # Attempt to fetch missing revisions from remote if they are not found
        fetchMissing: Boolean = true
    ): RepositoryComparison!
    # The repository's contributors.
    contributors(
        # The Git revision range to compute contributors in.
        revisionRange: String
        # The date after which to count contributions.
        after: String
        # Return contributors to files in this path.
        path: String
        # Returns the first n contributors from the list.
        first: Int
    ): RepositoryContributorConnection!
    # Whether the viewer has admin privileges on this repository.
    viewerCanAdminister: Boolean!
    # Base64 data uri to an icon.
    icon: String!
    # A markdown string that is rendered prominently.
    label: Markdown!
    # A markdown string of that is rendered less prominently.
    detail: Markdown!
    # The result previews of the result.
    matches: [SearchResultMatch!]!

    # (experimental) The LSIF API may change substantially in the near future as we
    # continue to adjust it for our use cases. Changes will not be documented in the
    # CHANGELOG during this time.
    # The repository's LSIF uploads.
    lsifUploads(
        # An (optional) search query that searches over the state, repository name,
        # commit, root, and indexer properties.
        query: String

        # The state of returned uploads.
        state: LSIFUploadState

        # When specified, shows only uploads that are latest for the given repository.
        isLatestForRepo: Boolean

        # When specified, indicates that this request should be paginated and
        # the first N results (relative to the cursor) should be returned. i.e.
        # how many results to return per page. It must be in the range of 0-5000.
        first: Int

        # When specified, indicates that this request should be paginated and
        # to fetch results starting at this cursor.
        #
        # A future request can be made for more results by passing in the
        # 'LSIFUploadConnection.pageInfo.endCursor' that is returned.
        after: String
    ): LSIFUploadConnection!

    # (experimental) The LSIF API may change substantially in the near future as we
    # continue to adjust it for our use cases. Changes will not be documented in the
    # CHANGELOG during this time.
    # The repository's LSIF uploads.
    lsifIndexes(
        # An (optional) search query that searches over the state, repository name,
        # and commit properties.
        query: String

        # The state of returned uploads.
        state: LSIFIndexState

        # When specified, indicates that this request should be paginated and
        # the first N results (relative to the cursor) should be returned. i.e.
        # how many results to return per page. It must be in the range of 0-5000.
        first: Int

        # When specified, indicates that this request should be paginated and
        # to fetch results starting at this cursor.
        #
        # A future request can be made for more results by passing in the
        # 'LSIFIndexConnection.pageInfo.endCursor' that is returned.
        after: String
    ): LSIFIndexConnection!

    # A list of authorized users to access this repository with the given permission.
    # This API currently only returns permissions from the Sourcegraph provider, i.e.
    # "permissions.userMapping" in site configuration.
    authorizedUsers(
        # Permission that the user has on this repository.
        permission: RepositoryPermission = READ
        # Number of users to return after the given cursor.
        first: Int!
        # Opaque pagination cursor.
        after: String
    ): UserConnection!

    # The permissions information of the repository for the authenticated user.
    # It is null when there is no permissions data stored for the repository.
    permissionsInfo: PermissionsInfo
}

# Permissions information of a repository or a user.
type PermissionsInfo {
    # The permission levels that a user has on the repository.
    permissions: [RepositoryPermission!]!
    # The last complete synced time, the value is updated only after a user- or repo-
    # centric sync of permissions. It is null when the complete sync never happened.
    syncedAt: DateTime
    # The last updated time of permissions, the value is updated whenever there is a
    # change to the database row (i.e. incremental update).
    updatedAt: DateTime!
}

# A reference to another Sourcegraph instance.
type Redirect {
    # The URL of the other Sourcegraph instance.
    url: String!
}

# A repository or a link to another Sourcegraph instance location where this repository may be located.
union RepositoryRedirect = Repository | Redirect

# A URL to a resource on an external service, such as the URL to a repository on its external (origin) code host.
type ExternalLink {
    # The URL to the resource.
    url: String!
    # The type of external service, such as "github", or null if unknown/unrecognized. This is used solely for
    # displaying an icon that represents the service.
    serviceType: String
}

# Information and status about the mirroring of a repository. In this case, the remote source repository
# is external to Sourcegraph and the mirror is maintained by the Sourcegraph site (not the other way
# around).
type MirrorRepositoryInfo {
    # The URL of the remote source repository.
    remoteURL: String!
    # Whether the clone of the repository has begun but not yet completed.
    cloneInProgress: Boolean!
    # A single line of text that contains progress information for the running clone command.
    # The format of the progress text is not specified.
    # It is intended to be displayed directly to a user.
    # e.g.
    # "Receiving objects:  95% (2041/2148), 292.01 KiB | 515.00 KiB/s"
    # "Resolving deltas:   9% (117/1263)"
    cloneProgress: String
    # Whether the repository has ever been successfully cloned.
    cloned: Boolean!
    # When the repository was last successfully updated from the remote source repository..
    updatedAt: DateTime
    # The state of this repository in the update schedule.
    updateSchedule: UpdateSchedule
    # The state of this repository in the update queue.
    updateQueue: UpdateQueue
}

# The state of a repository in the update schedule.
type UpdateSchedule {
    # The interval that was used when scheduling the current due time.
    intervalSeconds: Int!
    # The next time that the repo will be inserted into the update queue.
    due: DateTime!
    # The index of the repo in the schedule.
    index: Int!
    # The total number of repos in the schedule.
    total: Int!
}

# The state of a repository in the update queue.
type UpdateQueue {
    # The index of the repo in the update queue.
    # Updating repos are placed at the end of the queue until they finish updating
    # so don't display this if updating is true.
    index: Int!
    # True if the repo is currently updating.
    updating: Boolean!
    # The total number of repos in the update queue (including updating repos).
    total: Int!
}

# A repository on an external service (such as GitHub, GitLab, Phabricator, etc.).
type ExternalRepository {
    # The repository's ID on the external service.
    #
    # Example: For GitHub, this is the GitHub GraphQL API's node ID for the repository.
    id: String!
    # The type of external service where this repository resides.
    #
    # Example: "github", "gitlab", etc.
    serviceType: String!
    # The particular instance of the external service where this repository resides. Its value is
    # opaque but typically consists of the canonical base URL to the service.
    #
    # Example: For GitHub.com, this is "https://github.com/".
    serviceID: String!
}

# (experimental) A version context. Used to change the set of default repository and
# revisions searched.
#
# Note: We do not expose the list of repositories and revisions in the version
# context. This is intentional. However, if a need arises we can add it in.
type VersionContext implements Node {
    # The version context ID is its name.
    id: ID!

    # The name of the version context.
    name: String!

    # The description of the version context.
    description: String!
}

# Information about a repository's text search index.
type RepositoryTextSearchIndex {
    # The indexed repository.
    repository: Repository!
    # The status of the text search index, if available.
    status: RepositoryTextSearchIndexStatus
    # Git refs in the repository that are configured for text search indexing.
    refs: [RepositoryTextSearchIndexedRef!]!
}

# The status of a repository's text search index.
type RepositoryTextSearchIndexStatus {
    # The date that the index was last updated.
    updatedAt: DateTime!
    # The byte size of the original content.
    contentByteSize: Int!
    # The number of files in the original content.
    contentFilesCount: Int!
    # The byte size of the index.
    indexByteSize: Int!
    # The number of index shards.
    indexShardsCount: Int!
}

# A Git ref (usually a branch) in a repository that is configured to be indexed for text search.
type RepositoryTextSearchIndexedRef {
    # The Git ref (usually a branch) that is configured to be indexed for text search. To find the specific commit
    # SHA that was indexed, use RepositoryTextSearchIndexedRef.indexedCommit; this field's ref target resolves to
    # the current target, not the target at the time of indexing.
    ref: GitRef!
    # Whether a text search index exists for this ref.
    indexed: Boolean!
    # Whether the text search index is of the current commit for the Git ref. If false, the index is stale.
    current: Boolean!
    # The indexed Git commit (which may differ from the ref's current target if the index is out of date). If
    # indexed is false, this field's value is null.
    indexedCommit: GitObject
}

# A list of Git refs.
type GitRefConnection {
    # A list of Git refs.
    nodes: [GitRef!]!
    # The total count of Git refs in the connection. This total count may be larger
    # than the number of nodes in this object when the result is paginated.
    totalCount: Int!
    # Pagination information.
    pageInfo: PageInfo!
}

# Either a preview or an actual repository comparison.
union RepositoryComparisonInterface = RepositoryComparison | PreviewRepositoryComparison

# A not-yet-committed preview of a diff on a repository.
type PreviewRepositoryComparison {
    # The repository that is the base (left-hand side) of this comparison.
    baseRepository: Repository!

    # The file diffs for each changed file.
    fileDiffs(
        # Return the first n file diffs from the list.
        first: Int
        # Return file diffs after the given cursor.
        after: String
    ): FileDiffConnection!
}

# The differences between two concrete Git commits in a repository.
type RepositoryComparison {
    # The repository that is the base (left-hand side) of this comparison.
    baseRepository: Repository!

    # The repository that is the head (right-hand side) of this comparison. Cross-repository
    # comparisons are not yet supported, so this is always equal to
    # RepositoryComparison.baseRepository.
    headRepository: Repository!

    # The range that this comparison represents.
    range: GitRevisionRange!
    # The commits in the comparison range, excluding the base and including the head.
    commits(
        # Return the first n commits from the list.
        first: Int
    ): GitCommitConnection!
    # The file diffs for each changed file.
    fileDiffs(
        # Return the first n file diffs from the list.
        first: Int
        # Return file diffs after the given cursor.
        after: String
    ): FileDiffConnection!
}

# A list of file diffs.
type FileDiffConnection {
    # A list of file diffs.
    nodes: [FileDiff!]!
    # The total count of file diffs in the connection, if available. This total count may be larger than the number
    # of nodes in this object when the result is paginated.
    totalCount: Int
    # Pagination information.
    pageInfo: PageInfo!
    # The diff stat for the file diffs in this object, which may be a subset of the entire diff if the result is
    # paginated.
    diffStat: DiffStat!
    # The raw diff for the file diffs in this object, which may be a subset of the entire diff if the result is
    # paginated.
    rawDiff: String!
}

# A diff for a single file.
type FileDiff {
    # The old (original) path of the file, or null if the file was added.
    oldPath: String
    # The old file, or null if the file was created (oldFile.path == oldPath).
    oldFile: File2
    # The new (changed) path of the file, or null if the file was deleted.
    newPath: String
    # The new file, or null if the file was deleted (newFile.path == newPath).
    newFile: File2
    # The old file (if the file was deleted) and otherwise the new file. This file field is typically used by
    # clients that want to show a "View" link to the file.
    mostRelevantFile: File2!
    # Hunks that were changed from old to new.
    hunks: [FileDiffHunk!]!
    # The diff stat for the whole file.
    stat: DiffStat!
    # FOR INTERNAL USE ONLY.
    #
    # An identifier for the file diff that is unique among all other file diffs in the list that
    # contains it.
    internalID: String!
}

# The type of content in a hunk line.
enum DiffHunkLineType {
    # Added line.
    ADDED
    # Unchanged line.
    UNCHANGED
    # Deleted line.
    DELETED
}

# A single highlighted line, including the kind of line.
type HighlightedDiffHunkLine {
    # The HTML containing the syntax-highlighted line of code.
    html: String!
    # The operation that happened on this line, in patches it is prefixed with '+', '-', ' '.
    # Can be either add, delete, or no change.
    kind: DiffHunkLineType!
}

# A highlighted hunk, consisting of all its lines.
type HighlightedDiffHunkBody {
    # Whether highlighting was aborted.
    aborted: Boolean!
    # The highlighted lines.
    lines: [HighlightedDiffHunkLine!]!
}

# A changed region ("hunk") in a file diff.
type FileDiffHunk {
    # The range of the old file that the hunk applies to.
    oldRange: FileDiffHunkRange!
    # Whether the old file had a trailing newline.
    oldNoNewlineAt: Boolean!
    # The range of the new file that the hunk applies to.
    newRange: FileDiffHunkRange!
    # The diff hunk section heading, if any.
    section: String
    # The hunk body, with lines prefixed with '-', '+', or ' '.
    body: String!
    # Highlight the hunk.
    highlight(
        disableTimeout: Boolean!
        isLightTheme: Boolean!
        # If highlightLongLines is true, lines which are longer than 2000 bytes are highlighted.
        # 2000 bytes is enabled. This may produce a significant amount of HTML
        # which some browsers (such as Chrome, but not Firefox) may have trouble
        # rendering efficiently.
        highlightLongLines: Boolean = false
    ): HighlightedDiffHunkBody!
}

# A hunk range in one side (old/new) of a diff.
type FileDiffHunkRange {
    # The first line that the hunk applies to.
    startLine: Int!
    # The number of lines that the hunk applies to.
    lines: Int!
}

# Statistics about a diff.
type DiffStat {
    # Number of additions.
    added: Int!
    # Number of changes.
    changed: Int!
    # Number of deletions.
    deleted: Int!
}

# A list of contributors to a repository.
type RepositoryContributorConnection {
    # A list of contributors to a repository.
    nodes: [RepositoryContributor!]!
    # The total count of contributors in the connection, if available. This total count may be larger than the
    # number of nodes in this object when the result is paginated.
    totalCount: Int!
    # Pagination information.
    pageInfo: PageInfo!
}

# A contributor to a repository.
type RepositoryContributor {
    # The personal information for the contributor.
    person: Person!
    # The number of contributions made by this contributor.
    count: Int!
    # The repository in which the contributions occurred.
    repository: Repository!
    # Commits by the contributor.
    commits(
        # Return the first n commits.
        first: Int
    ): GitCommitConnection!
}

# A code symbol (e.g., a function, variable, type, class, etc.).
#
# It is derived from DocumentSymbol as defined in the Language Server Protocol (see
# https://microsoft.github.io/language-server-protocol/specifications/specification-3-14/#textDocument_documentSymbol).
type Symbol {
    # The name of the symbol.
    name: String!
    # The name of the symbol that contains this symbol, if any. This field's value is not guaranteed to be
    # structured in such a way that callers can infer a hierarchy of symbols.
    containerName: String
    # The kind of the symbol.
    kind: SymbolKind!
    # The programming language of the symbol.
    language: String!
    # The location where this symbol is defined.
    location: Location!
    # The URL to this symbol (using the input revision specifier, which may not be immutable).
    url: String!
    # The canonical URL to this symbol (using an immutable revision specifier).
    canonicalURL: String!
    # Whether or not the symbol is local to the file it's defined in.
    fileLocal: Boolean!
}

# A location inside a resource (in a repository at a specific commit).
type Location {
    # The file that this location refers to.
    resource: GitBlob!
    # The range inside the file that this location refers to.
    range: Range
    # The URL to this location (using the input revision specifier, which may not be immutable).
    url: String!
    # The canonical URL to this location (using an immutable revision specifier).
    canonicalURL: String!
}

# A range inside a file. The start position is inclusive, and the end position is exclusive.
type Range {
    # The start position of the range (inclusive).
    start: Position!
    # The end position of the range (exclusive).
    end: Position!
}

# A zero-based position inside a file.
type Position {
    # The line number (zero-based) of the position.
    line: Int!
    # The character offset (zero-based) in the line of the position.
    character: Int!
}

# A list of diagnostics.
type DiagnosticConnection {
    # A list of diagnostics.
    nodes: [Diagnostic!]!

    # The total count of diagnostics (which may be larger than nodes.length if the connection is paginated).
    totalCount: Int!

    # Pagination information.
    pageInfo: PageInfo!
}

# Represents a diagnostic, such as a compiler error or warning.
type Diagnostic {
    # The location at which the message applies.
    location: Location!

    # The diagnostic's severity.
    severity: DiagnosticSeverity

    # The diagnostic's code as provided by the tool.
    code: String

    # A human-readable string describing the source of this
    # diagnostic, e.g. "typescript" or "super lint".
    source: String

    # The diagnostic's message.
    message: String
}

# Represents the severity level of a diagnostic.
enum DiagnosticSeverity {
    ERROR
    WARNING
    INFORMATION
    HINT
}

# All possible kinds of symbols. This set matches that of the Language Server Protocol
# (https://microsoft.github.io/language-server-protocol/specification#workspace_symbol).
enum SymbolKind {
    UNKNOWN
    FILE
    MODULE
    NAMESPACE
    PACKAGE
    CLASS
    METHOD
    PROPERTY
    FIELD
    CONSTRUCTOR
    ENUM
    INTERFACE
    FUNCTION
    VARIABLE
    CONSTANT
    STRING
    NUMBER
    BOOLEAN
    ARRAY
    OBJECT
    KEY
    NULL
    ENUMMEMBER
    STRUCT
    EVENT
    OPERATOR
    TYPEPARAMETER
}

# A list of symbols.
type SymbolConnection {
    # A list of symbols.
    nodes: [Symbol!]!
    # Pagination information.
    pageInfo: PageInfo!
}

# A Git object ID (SHA-1 hash, 40 hexadecimal characters).
scalar GitObjectID

# A Git ref.
type GitRef implements Node {
    # The globally addressable ID for the Git ref.
    id: ID!
    # The full ref name (e.g., "refs/heads/mybranch" or "refs/tags/mytag").
    name: String!
    # An unambiguous short name for the ref.
    abbrevName: String!
    # The display name of the ref. For branches ("refs/heads/foo"), this is the branch
    # name ("foo").
    #
    # As a special case, for GitHub pull request refs of the form refs/pull/NUMBER/head,
    # this is "#NUMBER".
    displayName: String!
    # The prefix of the ref, either "", "refs/", "refs/heads/", "refs/pull/", or
    # "refs/tags/". This prefix is always a prefix of the ref's name.
    prefix: String!
    # The type of this Git ref.
    type: GitRefType!
    # The object that the ref points to.
    target: GitObject!
    # The associated repository.
    repository: Repository!
    # The URL to this Git ref.
    url: String!
}

# All possible types of Git refs.
enum GitRefType {
    # A Git branch (in refs/heads/).
    GIT_BRANCH
    # A Git tag (in refs/tags/).
    GIT_TAG
    # A Git ref that is neither a branch nor tag.
    GIT_REF_OTHER
}

# Ordering options for Git refs.
enum GitRefOrder {
    # By the authored or committed at date, whichever is more recent.
    AUTHORED_OR_COMMITTED_AT
}

# A Git object.
type GitObject {
    # This object's OID.
    oid: GitObjectID!
    # The abbreviated form of this object's OID.
    abbreviatedOID: String!
    # The commit object, if it is a commit and it exists; otherwise null.
    commit: GitCommit
    # The Git object's type.
    type: GitObjectType!
}

# All possible types of Git objects.
enum GitObjectType {
    # A Git commit object.
    GIT_COMMIT
    # A Git tag object.
    GIT_TAG
    # A Git tree object.
    GIT_TREE
    # A Git blob object.
    GIT_BLOB
    # A Git object of unknown type.
    GIT_UNKNOWN
}

# A Git revspec expression that (possibly) resolves to a Git revision.
type GitRevSpecExpr {
    # The original Git revspec expression.
    expr: String!
    # The Git object that the revspec resolves to, or null otherwise.
    object: GitObject
}

# A Git revspec.
union GitRevSpec = GitRef | GitRevSpecExpr | GitObject

# A Git revision range of the form "base..head" or "base...head". Other revision
# range formats are not supported.
type GitRevisionRange {
    # The Git revision range expression of the form "base..head" or "base...head".
    expr: String!
    # The base (left-hand side) of the range.
    base: GitRevSpec!
    # The base's revspec as an expression.
    baseRevSpec: GitRevSpecExpr!
    # The head (right-hand side) of the range.
    head: GitRevSpec!
    # The head's revspec as an expression.
    headRevSpec: GitRevSpecExpr!
    # The merge-base of the base and head revisions, if this is a "base...head"
    # revision range. If this is a "base..head" revision range, then this field is null.
    mergeBase: GitObject
}

# A Phabricator repository.
type PhabricatorRepo {
    # The canonical repo name (e.g. "github.com/gorilla/mux").
    name: String!
    # An alias for name.
    uri: String! @deprecated(reason: "use name instead")
    # The unique Phabricator identifier for the repo, like "MUX"
    callsign: String!
    # The URL to the phabricator instance (e.g. http://phabricator.sgdev.org)
    url: String!
}

# Pagination information. See https://facebook.github.io/relay/graphql/connections.htm#sec-undefined.PageInfo.
type PageInfo {
    # When paginating forwards, the cursor to continue.
    endCursor: String
    # When paginating forwards, are there more items?
    hasNextPage: Boolean!
}

# A list of Git commits.
type GitCommitConnection {
    # A list of Git commits.
    nodes: [GitCommit!]!
    # The total number of Git commits in the connection. If the GitCommitConnection is paginated
    # (e.g., because a "first" parameter was provided to the field that produced it), this field is
    # null to avoid it taking unexpectedly long to compute the total count. Remove the pagination
    # parameters to obtain a non-null value for this field.
    totalCount: Int
    # Pagination information.
    pageInfo: PageInfo!
}

# Statistics about a language's usage.
type LanguageStatistics {
    # The name of the language.
    name: String!

    # The total bytes in the language.
    totalBytes: Float!

    # The total number of lines in the language.
    totalLines: Int!
}

# A Git commit.
type GitCommit implements Node {
    # The globally addressable ID for this commit.
    id: ID!
    # The repository that contains this commit.
    repository: Repository!
    # This commit's Git object ID (OID), a 40-character SHA-1 hash.
    oid: GitObjectID!
    # The abbreviated form of this commit's OID.
    abbreviatedOID: String!
    # This commit's author.
    author: Signature!
    # This commit's committer, if any.
    committer: Signature
    # The full commit message.
    message: String!
    # The first line of the commit message.
    subject: String!
    # The contents of the commit message after the first line.
    body: String
    # Parent commits of this commit.
    parents: [GitCommit!]!
    # The URL to this commit (using the input revision specifier, which may not be immutable).
    url: String!
    # The canonical URL to this commit (using an immutable revision specifier).
    canonicalURL: String!
    # The URLs to this commit on its repository's external services.
    externalURLs: [ExternalLink!]!
    # The Git tree in this commit at the given path.
    tree(
        # The path of the tree.
        path: String = ""
        # Whether to recurse into sub-trees. If true, it overrides the value of the "recursive" parameter on all of
        # GitTree's fields.
        #
        # DEPRECATED: Use the "recursive" parameter on GitTree's fields instead.
        recursive: Boolean = false
    ): GitTree
    # The Git blob in this commit at the given path.
    blob(path: String!): GitBlob
    # The file at the given path for this commit.
    #
    # See "File" documentation for the difference between this field and the "blob" field.
    file(path: String!): File2
    # Lists the programming languages present in the tree at this commit.
    languages: [String!]!
    # List statistics for each language present in the repository.
    languageStatistics: [LanguageStatistics!]!
    # The log of commits consisting of this commit and its ancestors.
    ancestors(
        # Returns the first n commits from the list.
        first: Int
        # Return commits that match the query.
        query: String
        # Return commits that affect the path.
        path: String
        # Return commits more recent than the specified date.
        after: String
    ): GitCommitConnection!
    # Returns the number of commits that this commit is behind and ahead of revspec.
    behindAhead(revspec: String!): BehindAheadCounts!
    # Symbols defined as of this commit. (All symbols, not just symbols that were newly defined in this commit.)
    symbols(
        # Returns the first n symbols from the list.
        first: Int
        # Return symbols matching the query.
        query: String
        # A list of regular expressions, all of which must match all
        # file paths returned in the list.
        includePatterns: [String!]
    ): SymbolConnection!
}

# A set of Git behind/ahead counts for one commit relative to another.
type BehindAheadCounts {
    # The number of commits behind the other commit.
    behind: Int!
    # The number of commits ahead of the other commit.
    ahead: Int!
}

# A signature.
type Signature {
    # The person.
    person: Person!
    # The date.
    date: String!
}

# A person.
type Person {
    # The name.
    name: String!
    # The email.
    email: String!
    # The name if set; otherwise the email username.
    displayName: String!
    # The avatar URL.
    avatarURL: String!
    # The corresponding user account for this person, if one exists.
    user: User
}

# A Git submodule
type Submodule {
    # The remote repository URL of the submodule.
    url: String!
    # The commit of the submodule.
    commit: String!
    # The path to which the submodule is checked out.
    path: String!
}

# A file, directory, or other tree entry.
interface TreeEntry {
    # The full path (relative to the repository root) of this tree entry.
    path: String!
    # The base name (i.e., file name only) of this tree entry.
    name: String!
    # Whether this tree entry is a directory.
    isDirectory: Boolean!
    # The URL to this tree entry (using the input revision specifier, which may not be immutable).
    url: String!
    # The canonical URL to this tree entry (using an immutable revision specifier).
    canonicalURL: String!
    # The URLs to this tree entry on external services.
    externalURLs: [ExternalLink!]!
    # Symbols defined in this file or directory.
    symbols(
        # Returns the first n symbols from the list.
        first: Int
        # Return symbols matching the query.
        query: String
    ): SymbolConnection!
    # Submodule metadata if this tree points to a submodule
    submodule: Submodule
    # Whether this tree entry is a single child
    isSingleChild(
        # Returns the first n files in the tree.
        first: Int
        # Recurse into sub-trees.
        recursive: Boolean = false
        # Recurse into sub-trees of single-child directories
        recursiveSingleChild: Boolean = false
    ): Boolean!

    # (experimental) The LSIF API may change substantially in the near future as we
    # continue to adjust it for our use cases. Changes will not be documented in the
    # CHANGELOG during this time.
    # LSIF data for this tree entry.
    lsif(
        # An optional filter for the name of the tool that produced the upload data.
        toolName: String
    ): TreeEntryLSIFData
}

# A Git tree in a repository.
type GitTree implements TreeEntry {
    # The full path (relative to the root) of this tree.
    path: String!
    # Whether this tree is the root (top-level) tree.
    isRoot: Boolean!
    # The base name (i.e., last path component only) of this tree.
    name: String!
    # True because this is a directory. (The value differs for other TreeEntry interface implementations, such as
    # File.)
    isDirectory: Boolean!
    # The Git commit containing this tree.
    commit: GitCommit!
    # The repository containing this tree.
    repository: Repository!
    # The URL to this tree (using the input revision specifier, which may not be immutable).
    url: String!
    # The canonical URL to this tree (using an immutable revision specifier).
    canonicalURL: String!
    # The URLs to this tree on external services.
    externalURLs: [ExternalLink!]!
    # The URL to this entry's raw contents as a Zip archive.
    rawZipArchiveURL: String!
    # Submodule metadata if this tree points to a submodule
    submodule: Submodule
    # A list of directories in this tree.
    directories(
        # Returns the first n files in the tree.
        first: Int
        # Recurse into sub-trees.
        recursive: Boolean = false
    ): [GitTree!]!
    # A list of files in this tree.
    files(
        # Returns the first n files in the tree.
        first: Int
        # Recurse into sub-trees.
        recursive: Boolean = false
    ): [File!]!
    # A list of entries in this tree.
    entries(
        # Returns the first n files in the tree.
        first: Int
        # Recurse into sub-trees. If true, implies recursiveSingleChild.
        recursive: Boolean = false
        # Recurse into sub-trees of single-child directories. If true, we return a flat list of
        # every directory that is a single child, and any directories or files that are
        # nested in a single child.
        recursiveSingleChild: Boolean = false
    ): [TreeEntry!]!
    # Symbols defined in this tree.
    symbols(
        # Returns the first n symbols from the list.
        first: Int
        # Return symbols matching the query.
        query: String
    ): SymbolConnection!
    # Whether this tree entry is a single child
    isSingleChild(
        # Returns the first n files in the tree.
        first: Int
        # Recurse into sub-trees.
        recursive: Boolean = false
        # Recurse into sub-trees of single-child directories
        recursiveSingleChild: Boolean = false
    ): Boolean!

    # (experimental) The LSIF API may change substantially in the near future as we
    # continue to adjust it for our use cases. Changes will not be documented in the
    # CHANGELOG during this time.
    # LSIF data for this tree entry.
    lsif(
        # An optional filter for the name of the tool that produced the upload data.
        toolName: String
    ): TreeEntryLSIFData
}

# A file.
#
# In a future version of Sourcegraph, a repository's files may be distinct from a repository's blobs
# (for example, to support searching/browsing generated files that aren't committed and don't exist
# as Git blobs). Clients should generally use the GitBlob concrete type and GitCommit.blobs (not
# GitCommit.files), unless they explicitly want to opt-in to different behavior in the future.
#
# INTERNAL: This is temporarily named File2 during a migration. Do not refer to the name File2 in
# any API clients as the name will change soon.
interface File2 {
    # The full path (relative to the root) of this file.
    path: String!
    # The base name (i.e., file name only) of this file.
    name: String!
    # False because this is a file, not a directory.
    isDirectory: Boolean!
    # The content of this file.
    content: String!
    # The file size in bytes.
    byteSize: Int!
    # Whether or not it is binary.
    binary: Boolean!
    # The file rendered as rich HTML, or an empty string if it is not a supported
    # rich file type.
    #
    # This HTML string is already escaped and thus is always safe to render.
    richHTML: String!
    # The URL to this file (using the input revision specifier, which may not be immutable).
    url: String!
    # The canonical URL to this file (using an immutable revision specifier).
    canonicalURL: String!
    # The URLs to this file on external services.
    externalURLs: [ExternalLink!]!
    # Highlight the file.
    highlight(
        disableTimeout: Boolean!
        isLightTheme: Boolean!
        # If highlightLongLines is true, lines which are longer than 2000 bytes are highlighted.
        # 2000 bytes is enabled. This may produce a significant amount of HTML
        # which some browsers (such as Chrome, but not Firefox) may have trouble
        # rendering efficiently.
        highlightLongLines: Boolean = false
    ): HighlightedFile!
}

# A virtual file is an arbitrary file that is generated in memory.
type VirtualFile implements File2 {
    # The full path (relative to the root) of this file.
    path: String!
    # The base name (i.e., file name only) of this file.
    name: String!
    # False because this is a file, not a directory.
    isDirectory: Boolean!
    # The content of this file.
    content: String!
    # The file size in bytes.
    byteSize: Int!
    # Whether or not it is binary.
    binary: Boolean!
    # The file rendered as rich HTML, or an empty string if it is not a supported
    # rich file type.
    #
    # This HTML string is already escaped and thus is always safe to render.
    richHTML: String!
    # Not implemented.
    url: String!
    # Not implemented.
    canonicalURL: String!
    # Not implemented.
    externalURLs: [ExternalLink!]!
    # Highlight the file.
    highlight(
        disableTimeout: Boolean!
        isLightTheme: Boolean!
        # If highlightLongLines is true, lines which are longer than 2000 bytes are highlighted.
        # 2000 bytes is enabled. This may produce a significant amount of HTML
        # which some browsers (such as Chrome, but not Firefox) may have trouble
        # rendering efficiently.
        highlightLongLines: Boolean = false
    ): HighlightedFile!
}

# File is temporarily preserved for backcompat with browser extension search API client code.
type File {
    # The full path (relative to the repository root) of this file.
    path: String!
    # The base name (i.e., file name only) of this file's path.
    name: String!
    # Whether this is a directory.
    isDirectory: Boolean!
    # The URL to this file on Sourcegraph.
    url: String!
    # The repository that contains this file.
    repository: Repository!
}

# A Git blob in a repository.
type GitBlob implements TreeEntry & File2 {
    # The full path (relative to the repository root) of this blob.
    path: String!
    # The base name (i.e., file name only) of this blob's path.
    name: String!
    # False because this is a blob (file), not a directory.
    isDirectory: Boolean!
    # The content of this blob.
    content: String!
    # The file size in bytes.
    byteSize: Int!
    # Whether or not it is binary.
    binary: Boolean!
    # The blob contents rendered as rich HTML, or an empty string if it is not a supported
    # rich file type.
    #
    # This HTML string is already escaped and thus is always safe to render.
    richHTML: String!
    # The Git commit containing this blob.
    commit: GitCommit!
    # The repository containing this Git blob.
    repository: Repository!
    # The URL to this blob (using the input revision specifier, which may not be immutable).
    url: String!
    # The canonical URL to this blob (using an immutable revision specifier).
    canonicalURL: String!
    # The URLs to this blob on its repository's external services.
    externalURLs: [ExternalLink!]!
    # Blame the blob.
    blame(startLine: Int!, endLine: Int!): [Hunk!]!
    # Highlight the blob contents.
    highlight(disableTimeout: Boolean!, isLightTheme: Boolean!, highlightLongLines: Boolean = false): HighlightedFile!
    # Submodule metadata if this tree points to a submodule
    submodule: Submodule
    # Symbols defined in this blob.
    symbols(
        # Returns the first n symbols from the list.
        first: Int
        # Return symbols matching the query.
        query: String
    ): SymbolConnection!
    # Always false, since a blob is a file, not directory.
    isSingleChild(
        # Returns the first n files in the tree.
        first: Int
        # Recurse into sub-trees.
        recursive: Boolean = false
        # Recurse into sub-trees of single-child directories
        recursiveSingleChild: Boolean = false
    ): Boolean!

    # (experimental) The LSIF API may change substantially in the near future as we
    # continue to adjust it for our use cases. Changes will not be documented in the
    # CHANGELOG during this time.
    # A wrapper around LSIF query methods. If no LSIF upload can be used to answer code
    # intelligence queries for this path-at-revision, this resolves to null.
    lsif(
        # An optional filter for the name of the tool that produced the upload data.
        toolName: String
    ): GitBlobLSIFData
}

# LSIF data available for a tree entry.
interface TreeEntryLSIFData {
    # Code diagnostics provided through LSIF.
    diagnostics(first: Int): DiagnosticConnection!
}

# A wrapper object around LSIF query methods for a particular path-at-revision. When this node is
# null, no LSIF data is available for containing git blob.
type GitBlobLSIFData implements TreeEntryLSIFData {
    # (experimental) The LSIF API may change substantially in the near future as we
    # continue to adjust it for our use cases. Changes will not be documented in the
    # CHANGELOG during this time.
    # Get aggregated local code intelligence for all ranges that fall in the window
    # indicated by the given zero-based start (inclusive) and end (exclusive) lines.
    # The associated data for each range is "local", in that the locations and hover
    # must also be defined in the same index as the source range. To get cross-repository
    # and cross-bundle results, you must query the definitions, references, and hovers
    # of that range explicitly.
    ranges(startLine: Int!, endLine: Int!): CodeIntelligenceRangeConnection

    # (experimental) The LSIF API may change substantially in the near future as we
    # continue to adjust it for our use cases. Changes will not be documented in the
    # CHANGELOG during this time.
    # A list of definitions of the symbol under the given document position.
    definitions(
        # The line on which the symbol occurs (zero-based, inclusive).
        line: Int!

        # The character (not byte) of the start line on which the symbol occurs (zero-based, inclusive).
        character: Int!
    ): LocationConnection!

    # (experimental) The LSIF API may change substantially in the near future as we
    # continue to adjust it for our use cases. Changes will not be documented in the
    # CHANGELOG during this time.
    # A list of references of the symbol under the given document position.
    references(
        # The line on which the symbol occurs (zero-based, inclusive).
        line: Int!

        # The character (not byte) of the start line on which the symbol occurs (zero-based, inclusive).
        character: Int!

        # When specified, indicates that this request should be paginated and
        # to fetch results starting at this cursor.
        #
        # A future request can be made for more results by passing in the
        # 'LocationConnection.pageInfo.endCursor' that is returned.
        after: String

        # When specified, indicates that this request should be paginated and
        # the first N results (relative to the cursor) should be returned. i.e.
        # how many results to return per page.
        first: Int
    ): LocationConnection!

    # (experimental) The LSIF API may change substantially in the near future as we
    # continue to adjust it for our use cases. Changes will not be documented in the
    # CHANGELOG during this time.
    # The hover result of the symbol under the given document position.
    hover(
        # The line on which the symbol occurs (zero-based, inclusive).
        line: Int!

        # The character (not byte) of the start line on which the symbol occurs (zero-based, inclusive).
        character: Int!
    ): Hover

    # (experimental) The LSIF API may change substantially in the near future as we
    # continue to adjust it for our use cases. Changes will not be documented in the
    # CHANGELOG during this time.
    # Code diagnostics provided through LSIF.
    diagnostics(first: Int): DiagnosticConnection!
}

# A highlighted file.
type HighlightedFile {
    # Whether or not it was aborted.
    aborted: Boolean!
    # The HTML.
    html: String!
}

# A file match.
type FileMatch {
    # The file containing the match.
    #
    # KNOWN ISSUE: This file's "commit" field contains incomplete data.
    #
    # KNOWN ISSUE: This field's type should be File! not GitBlob!.
    file: GitBlob!
    # The repository containing the file match.
    repository: Repository!
    # The revspec of the revision that contains this match. If no revspec was given (such as when no
    # repository filter or revspec is specified in the search query), it is null.
    revSpec: GitRevSpec
    # The resource.
    resource: String! @deprecated(reason: "use the file field instead")
    # The symbols found in this file that match the query.
    symbols: [Symbol!]!
    # The line matches.
    lineMatches: [LineMatch!]!
    # Whether or not the limit was hit.
    limitHit: Boolean!
}

# A line match.
type LineMatch {
    # The preview.
    preview: String!
    # The line number. 0-based. The first line will have lineNumber 0. Note: A
    # UI will normally display line numbers 1-based.
    lineNumber: Int!
    # Tuples of [offset, length] measured in characters (not bytes).
    offsetAndLengths: [[Int!]!]!
    # Whether or not the limit was hit.
    limitHit: Boolean!
}

# A hunk.
type Hunk {
    # The startLine.
    startLine: Int!
    # The endLine.
    endLine: Int!
    # The startByte.
    startByte: Int!
    # The endByte.
    endByte: Int!
    # The rev.
    rev: String!
    # The author.
    author: Signature!
    # The message.
    message: String!
    # The commit that contains the hunk.
    commit: GitCommit!
}

# A namespace is a container for certain types of data and settings, such as a user or organization.
interface Namespace {
    # The globally unique ID of this namespace.
    id: ID!

    # The name of this namespace's component. For a user, this is the username. For an organization,
    # this is the organization name.
    namespaceName: String!

    # The URL to this namespace.
    url: String!
}

# A list of users.
type UserConnection {
    # A list of users.
    nodes: [User!]!
    # The total count of users in the connection. This total count may be larger
    # than the number of nodes in this object when the result is paginated.
    totalCount: Int!
    # Pagination information.
    pageInfo: PageInfo!
}

# A user.
type User implements Node & SettingsSubject & Namespace {
    # The unique ID for the user.
    id: ID!
    # The user's username.
    username: String!
    # The user's primary email address.
    #
    # Only the user and site admins can access this field.
    email: String! @deprecated(reason: "use emails instead")
    # The display name chosen by the user.
    displayName: String
    # The URL of the user's avatar image.
    avatarURL: String
    # The URL to the user's profile on Sourcegraph.
    url: String!
    # The URL to the user's settings.
    settingsURL: String
    # The date when the user account was created on Sourcegraph.
    createdAt: DateTime!
    # The date when the user account was last updated on Sourcegraph.
    updatedAt: DateTime
    # Whether the user is a site admin.
    #
    # Only the user and site admins can access this field.
    siteAdmin: Boolean!
    # Whether the user account uses built in auth.
    builtinAuth: Boolean!
    # The latest settings for the user.
    #
    # Only the user and site admins can access this field.
    latestSettings: Settings
    # All settings for this user, and the individual levels in the settings cascade (global > organization > user)
    # that were merged to produce the final merged settings.
    #
    # Only the user and site admins can access this field.
    settingsCascade: SettingsCascade!
    # DEPRECATED
    configurationCascade: ConfigurationCascade!
        @deprecated(
            reason: "Use settingsCascade instead. This field is a deprecated alias for it and will be removed in a future release."
        )
    # The organizations that this user is a member of.
    organizations: OrgConnection!
    # This user's organization memberships.
    organizationMemberships: OrganizationMembershipConnection!
    # Tags associated with the user. These are used for internal site management and feature selection.
    #
    # Only the user and site admins can access this field.
    tags: [String!]!
    # The user's usage statistics on Sourcegraph.
    usageStatistics: UserUsageStatistics!
    # The user's events on Sourcegraph.
    eventLogs(
        # Returns the first n event logs from the list.
        first: Int
    ): EventLogsConnection!
    # The user's email addresses.
    #
    # Only the user and site admins can access this field.
    emails: [UserEmail!]!
    # The user's access tokens (which grant to the holder the privileges of the user). This consists
    # of all access tokens whose subject is this user.
    #
    # Only the user and site admins can access this field.
    accessTokens(
        # Returns the first n access tokens from the list.
        first: Int
    ): AccessTokenConnection!
    # A list of external accounts that are associated with the user.
    externalAccounts(
        # Returns the first n external accounts from the list.
        first: Int
    ): ExternalAccountConnection!
    # The user's currently active session.
    #
    # Only the currently authenticated user can access this field. Site admins are not able to access sessions for
    # other users.
    session: Session!
    # Whether the viewer has admin privileges on this user. The user has admin privileges on their own user, and
    # site admins have admin privileges on all users.
    viewerCanAdminister: Boolean!
    # Whether the viewer can change the username of this user.
    #
    # The user can change their username unless auth.disableUsernameChanges is set.
    # Site admins can always change the username of any user.
    viewerCanChangeUsername: Boolean!
    # The user's survey responses.
    #
    # Only the user and site admins can access this field.
    surveyResponses: [SurveyResponse!]!
    # The URL to view this user's customer information (for Sourcegraph.com site admins).
    #
    # Only Sourcegraph.com site admins may query this field.
    #
    # FOR INTERNAL USE ONLY.
    urlForSiteAdminBilling: String
    # The unique numeric ID for the user.
    #
    # FOR INTERNAL USE ONLY.
    databaseID: Int!

    # The name of this user namespace's component. For users, this is the username.
    namespaceName: String!

    # The permissions information of the user over repositories.
    # It is null when there is no permissions data stored for the user.
    permissionsInfo: PermissionsInfo
}

# An access token that grants to the holder the privileges of the user who created it.
type AccessToken implements Node {
    # The unique ID for the access token.
    id: ID!
    # The user whose privileges the access token grants.
    subject: User!
    # The scopes that define the allowed set of operations that can be performed using this access token.
    scopes: [String!]!
    # A user-supplied descriptive note for the access token.
    note: String!
    # The user who created the access token. This is either the subject user (if the access token
    # was created by the same user) or a site admin (who can create access tokens for any user).
    creator: User!
    # The date when the access token was created.
    createdAt: DateTime!
    # The date when the access token was last used to authenticate a request.
    lastUsedAt: DateTime
}

# A list of access tokens.
type AccessTokenConnection {
    # A list of access tokens.
    nodes: [AccessToken!]!
    # The total count of access tokens in the connection. This total count may be larger than the number of nodes
    # in this object when the result is paginated.
    totalCount: Int!
    # Pagination information.
    pageInfo: PageInfo!
}

# A list of authentication providers.
type AuthProviderConnection {
    # A list of authentication providers.
    nodes: [AuthProvider!]!
    # The total count of authentication providers in the connection. This total count may be larger than the number of nodes
    # in this object when the result is paginated.
    totalCount: Int!
    # Pagination information.
    pageInfo: PageInfo!
}

# A provider of user authentication, such as an external single-sign-on service (e.g., using OpenID Connect or
# SAML). The provider information in this type is visible to all viewers and does not contain any secret values.
type AuthProvider {
    # The type of the auth provider.
    serviceType: String!
    # An identifier for the service that the auth provider represents.
    serviceID: String!
    # An identifier for the client of the service that the auth provider represents.
    clientID: String!
    # The human-readable name of the provider.
    displayName: String!
    # Whether this auth provider is the builtin username-password auth provider.
    isBuiltin: Boolean!
    # A URL that, when visited, initiates the authentication process for this auth provider.
    authenticationURL: String
}

# A list of external accounts.
type ExternalAccountConnection {
    # A list of external accounts.
    nodes: [ExternalAccount!]!
    # The total count of external accounts in the connection. This total count may be larger than the number of nodes
    # in this object when the result is paginated.
    totalCount: Int!
    # Pagination information.
    pageInfo: PageInfo!
}

# An external account associated with a user.
type ExternalAccount implements Node {
    # The unique ID for the external account.
    id: ID!
    # The user on Sourcegraph.
    user: User!
    # The type of the external service where the external account resides.
    serviceType: String!
    # An identifier for the external service where the external account resides.
    serviceID: String!
    # An identifier for the client of the external service where the external account resides. This distinguishes
    # among multiple authentication providers that access the same service with different parameters.
    clientID: String!
    # An identifier for the external account (typically equal to or derived from the ID on the external service).
    accountID: String!
    # The creation date of this external account on Sourcegraph.
    createdAt: DateTime!
    # The last-updated date of this external account on Sourcegraph.
    updatedAt: DateTime!
    # A URL that, when visited, re-initiates the authentication process.
    refreshURL: String
    # Provider-specific data about the external account.
    #
    # Only site admins may query this field.
    accountData: JSONValue
}

# An active user session.
type Session {
    # Whether the user can sign out of this session on Sourcegraph.
    canSignOut: Boolean!
}

# An organization membership.
type OrganizationMembership {
    # The organization.
    organization: Org!
    # The user.
    user: User!
    # The time when this was created.
    createdAt: DateTime!
    # The time when this was updated.
    updatedAt: DateTime!
}

# A list of organization memberships.
type OrganizationMembershipConnection {
    # A list of organization memberships.
    nodes: [OrganizationMembership!]!
    # The total count of organization memberships in the connection. This total count may be larger than the number
    # of nodes in this object when the result is paginated.
    totalCount: Int!
}

# A user's email address.
type UserEmail {
    # The email address.
    email: String!
    # Whether the email address is the user's primary email address. Currently this is defined as the earliest
    # email address associated with the user, preferring verified emails to unverified emails.
    isPrimary: Boolean!
    # Whether the email address has been verified by the user.
    verified: Boolean!
    # Whether the email address is pending verification.
    verificationPending: Boolean!
    # The user associated with this email address.
    user: User!
    # Whether the viewer has privileges to manually mark this email address as verified (without the user going
    # through the normal verification process). Only site admins have this privilege.
    viewerCanManuallyVerify: Boolean!
}

# A list of organizations.
type OrgConnection {
    # A list of organizations.
    nodes: [Org!]!
    # The total count of organizations in the connection. This total count may be larger
    # than the number of nodes in this object when the result is paginated.
    totalCount: Int!
}

# An organization, which is a group of users.
type Org implements Node & SettingsSubject & Namespace {
    # The unique ID for the organization.
    id: ID!
    # The organization's name. This is unique among all organizations on this Sourcegraph site.
    name: String!
    # The organization's chosen display name.
    displayName: String
    # The date when the organization was created.
    createdAt: DateTime!
    # A list of users who are members of this organization.
    members: UserConnection!
    # The latest settings for the organization.
    #
    # Only organization members and site admins can access this field.
    latestSettings: Settings
    # All settings for this organization, and the individual levels in the settings cascade (global > organization)
    # that were merged to produce the final merged settings.
    #
    # Only organization members and site admins can access this field.
    settingsCascade: SettingsCascade!
    # DEPRECATED
    configurationCascade: ConfigurationCascade!
        @deprecated(
            reason: "Use settingsCascade instead. This field is a deprecated alias for it and will be removed in a future release."
        )
    # A pending invitation for the viewer to join this organization, if any.
    viewerPendingInvitation: OrganizationInvitation
    # Whether the viewer has admin privileges on this organization. Currently, all of an organization's members
    # have admin privileges on the organization.
    viewerCanAdminister: Boolean!
    # Whether the viewer is a member of this organization.
    viewerIsMember: Boolean!
    # The URL to the organization.
    url: String!
    # The URL to the organization's settings.
    settingsURL: String

    # The name of this user namespace's component. For organizations, this is the organization's name.
    namespaceName: String!
}

# The result of Mutation.inviteUserToOrganization.
type InviteUserToOrganizationResult {
    # Whether an invitation email was sent. If emails are not enabled on this site or if the user has no verified
    # email address, an email will not be sent.
    sentInvitationEmail: Boolean!
    # The URL that the invited user can visit to accept or reject the invitation.
    invitationURL: String!
}

# An invitation to join an organization as a member.
type OrganizationInvitation implements Node {
    # The ID of the invitation.
    id: ID!
    # The organization that the invitation is for.
    organization: Org!
    # The user who sent the invitation.
    sender: User!
    # The user who received the invitation.
    recipient: User!
    # The date when this invitation was created.
    createdAt: DateTime!
    # The most recent date when a notification was sent to the recipient about this invitation.
    notifiedAt: DateTime
    # The date when this invitation was responded to by the recipient.
    respondedAt: DateTime
    # The recipient's response to this invitation, or no response (null).
    responseType: OrganizationInvitationResponseType
    # The URL where the recipient can respond to the invitation when pending, or null if not pending.
    respondURL: String
    # The date when this invitation was revoked.
    revokedAt: DateTime
}

# The recipient's possible responses to an invitation to join an organization as a member.
enum OrganizationInvitationResponseType {
    # The invitation was accepted by the recipient.
    ACCEPT
    # The invitation was rejected by the recipient.
    REJECT
}

# RepositoryOrderBy enumerates the ways a repositories list can be ordered.
enum RepositoryOrderBy {
    REPOSITORY_NAME
    REPO_CREATED_AT # deprecated (use the equivalent REPOSITORY_CREATED_AT)
    REPOSITORY_CREATED_AT
}

# The default settings for the Sourcegraph instance. This is hardcoded in
# Sourcegraph, but may change from release to release.
type DefaultSettings implements SettingsSubject {
    # The opaque GraphQL ID.
    id: ID!
    # The latest default settings (this never changes).
    latestSettings: Settings
    # The URL to the default settings. This URL does not exist because you
    # cannot edit or directly view default settings.
    settingsURL: String
    # Whether the viewer can modify the subject's settings. Always false for
    # default settings.
    viewerCanAdminister: Boolean!
    # The default settings, and the final merged settings.
    #
    # All viewers can access this field.
    settingsCascade: SettingsCascade!
    # DEPRECATED
    configurationCascade: ConfigurationCascade!
        @deprecated(
            reason: "Use settingsCascade instead. This field is a deprecated alias for it and will be removed in a future release."
        )
}

# A site is an installation of Sourcegraph that consists of one or more
# servers that share the same configuration and database.
#
# The site is a singleton; the API only ever returns the single global site.
type Site implements SettingsSubject {
    # The site's opaque GraphQL ID. This is NOT the "site ID" as it is referred to elsewhere;
    # use the siteID field for that. (GraphQL node types conventionally have an id field of type
    # ID! that globally identifies the node.)
    id: ID!
    # The site ID.
    siteID: String!
    # The site's configuration. Only visible to site admins.
    configuration: SiteConfiguration!
    # The site's latest site-wide settings (which are the second-lowest-precedence
    # in the configuration cascade for a user).
    latestSettings: Settings
    # The global settings for this site, and the final merged settings.
    #
    # All viewers can access this field.
    settingsCascade: SettingsCascade!
    # DEPRECATED
    configurationCascade: ConfigurationCascade!
        @deprecated(
            reason: "Use settingsCascade instead. This field is a deprecated alias for it and will be removed in a future release."
        )
    # The URL to the site's settings.
    settingsURL: String
    # Whether the viewer can reload the site (with the reloadSite mutation).
    canReloadSite: Boolean!
    # Whether the viewer can modify the subject's settings.
    viewerCanAdminister: Boolean!
    # A list of all access tokens on this site.
    accessTokens(
        # Returns the first n access tokens from the list.
        first: Int
    ): AccessTokenConnection!
    # A list of all authentication providers. This information is visible to all viewers and does not contain any
    # secret information.
    authProviders: AuthProviderConnection!
    # A list of all user external accounts on this site.
    externalAccounts(
        # Returns the first n external accounts from the list.
        first: Int
        # Include only external accounts associated with this user.
        user: ID
        # Include only external accounts with this service type.
        serviceType: String
        # Include only external accounts with this service ID.
        serviceID: String
        # Include only external accounts with this client ID.
        clientID: String
    ): ExternalAccountConnection!
    # The build version of the Sourcegraph software that is running on this site (of the form
    # NNNNN_YYYY-MM-DD_XXXXX, like 12345_2018-01-01_abcdef).
    buildVersion: String!
    # The product version of the Sourcegraph software that is running on this site.
    productVersion: String!
    # Information about software updates for the version of Sourcegraph that this site is running.
    updateCheck: UpdateCheck!
    # Whether the site needs to be configured to add repositories.
    needsRepositoryConfiguration: Boolean!
    # Whether the site is over the limit for free user accounts, and a warning needs to be shown to all users.
    # Only applies if the site does not have a valid license.
    freeUsersExceeded: Boolean!

    # DEPRECATED: This field is always false and will be removed in future
    # releases. All repositories are enabled by default starting with
    # Sourcegraph 3.4
    #
    # Whether the site has zero access-enabled repositories.
    noRepositoriesEnabled: Boolean!
        @deprecated(reason: "All repositories are enabled by default now. This field is always false.")
    # Alerts to display to the viewer.
    alerts: [Alert!]!
    # BACKCOMPAT: Always returns true.
    hasCodeIntelligence: Boolean!
    # Whether we want to show built-in searches on the saved searches page
    disableBuiltInSearches: Boolean!
    # Whether the server sends emails to users to verify email addresses. If false, then site admins must manually
    # verify users' email addresses.
    sendsEmailVerificationEmails: Boolean!
    # Information about this site's product subscription status.
    productSubscription: ProductSubscriptionStatus!
    # Usage statistics for this site.
    usageStatistics(
        # Days of history (based on current UTC time).
        days: Int
        # Weeks of history (based on current UTC time).
        weeks: Int
        # Months of history (based on current UTC time).
        months: Int
    ): SiteUsageStatistics!
    # Monitoring overview for this site.
    #
    # Note: This is primarily used for displaying recently-fired alerts in the web app. If your intent
    # is to monitor Sourcegraph, it is better to configure alerting or query Prometheus directly in
    # order to ensure that if the frontend goes down you still recieve alerts:
    #
    # Configure alerting: https://docs.sourcegraph.com/admin/observability/alerting
    # Query Prometheus directly: https://docs.sourcegraph.com/admin/observability/alerting_custom_consumption
    #
    monitoringStatistics(
        # Days of history (based on current UTC time).
        days: Int
    ): MonitoringStatistics!
}

# The configuration for a site.
type SiteConfiguration {
    # The unique identifier of this site configuration version.
    id: Int!
    # The effective configuration JSON.
    effectiveContents: JSONCString!
    # Messages describing validation problems or usage of deprecated configuration in the configuration JSON.
    # This includes both JSON Schema validation problems and other messages that perform more advanced checks
    # on the configuration (that can't be expressed in the JSON Schema).
    validationMessages: [String!]!
}

# Information about software updates for Sourcegraph.
type UpdateCheck {
    # Whether an update check is currently in progress.
    pending: Boolean!
    # When the last update check was completed, or null if no update check has
    # been completed (or performed) yet.
    checkedAt: DateTime
    # If an error occurred during the last update check, this message describes
    # the error.
    errorMessage: String
    # If an update is available, the version string of the updated version.
    updateVersionAvailable: String
}

# The possible types of alerts (Alert.type values).
enum AlertType {
    INFO
    WARNING
    ERROR
}

# An alert message shown to the viewer.
type Alert {
    # The type of this alert.
    type: AlertType!
    # The message body of this alert. Markdown is supported.
    message: String!
    # If set, this alert is dismissible. After being dismissed, no other alerts with the same
    # isDismissibleWithKey value will be shown. If null, this alert is not dismissible.
    isDismissibleWithKey: String
}

# SettingsSubject is something that can have settings: a site ("global settings", which is different from "site
# configuration"), an organization, or a user.
interface SettingsSubject {
    # The ID.
    id: ID!
    # The latest settings.
    latestSettings: Settings
    # The URL to the settings.
    settingsURL: String
    # Whether the viewer can modify the subject's settings.
    viewerCanAdminister: Boolean!
    # All settings for this subject, and the individual levels in the settings cascade (global > organization > user)
    # that were merged to produce the final merged settings.
    settingsCascade: SettingsCascade!
    # DEPRECATED
    configurationCascade: ConfigurationCascade!
        @deprecated(
            reason: "Use settingsCascade instead. This field is a deprecated alias for it and will be removed in a future release."
        )
}

# The configurations for all of the relevant settings subjects, plus the merged settings.
type SettingsCascade {
    # The other settings subjects that are applied with lower precedence than this subject to
    # form the final merged settings. For example, a user in 2 organizations would have the following
    # settings subjects: site (global settings), org 1, org 2, and the user.
    subjects: [SettingsSubject!]!
    # The effective final merged settings as (stringified) JSON, merged from all of the subjects.
    final: String!
    # DEPRECATED: This field will be removed in a future release.
    #
    # The effective final merged settings, merged from all of the subjects.
    merged: Configuration! @deprecated(reason: "use final instead")
}

# DEPRECATED: Renamed to SettingsCascade.
type ConfigurationCascade {
    # DEPRECATED
    subjects: [SettingsSubject!]! @deprecated(reason: "use SettingsCascade.subjects instead")
    # DEPRECATED
    merged: Configuration! @deprecated(reason: "use SettingsCascade.final instead")
}

# Settings is a version of a configuration settings file.
type Settings {
    # The ID.
    id: Int!
    # The subject that these settings are for.
    subject: SettingsSubject!
    # The author, or null if there is no author or the authoring user was deleted.
    author: User
    # The time when this was created.
    createdAt: DateTime!
    # The stringified JSON contents of the settings. The contents may include "//"-style comments and trailing
    # commas in the JSON.
    contents: JSONCString!
    # DEPRECATED: This field will be removed in a future release.
    #
    # The configuration.
    configuration: Configuration! @deprecated(reason: "use the contents field instead")
}

# DEPRECATED: Use the contents field on the parent type instead. This type will be removed in a future release.
type Configuration {
    # DEPRECATED: This field will be removed in a future release.
    #
    # The raw JSON contents, encoded as a string.
    contents: JSONCString! @deprecated(reason: "use the contents field on the parent type instead")
    # DEPRECATED: This field is always empty. It will be removed in a future release.
    messages: [String!]! @deprecated(reason: "use client-side JSON Schema validation instead")
}

# UserUsageStatistics describes a user's usage statistics.
#
# This information is visible to all viewers.
type UserUsageStatistics {
    # The number of search queries that the user has performed.
    searchQueries: Int!
    # The number of page views that the user has performed.
    pageViews: Int!
    # The number of code intelligence actions that the user has performed.
    codeIntelligenceActions: Int!
    # The number of find-refs actions that the user has performed.
    findReferencesActions: Int!
    # The last time the user was active (any action, any platform).
    lastActiveTime: String
    # The last time the user was active on a code host integration.
    lastActiveCodeHostIntegrationTime: String
}

# A user event.
enum UserEvent {
    PAGEVIEW
    SEARCHQUERY
    CODEINTEL
    CODEINTELREFS
    CODEINTELINTEGRATION
    CODEINTELINTEGRATIONREFS

    # Product stages
    STAGEMANAGE
    STAGEPLAN
    STAGECODE
    STAGEREVIEW
    STAGEVERIFY
    STAGEPACKAGE
    STAGEDEPLOY
    STAGECONFIGURE
    STAGEMONITOR
    STAGESECURE
    STAGEAUTOMATE
}

# A period of time in which a set of users have been active.
enum UserActivePeriod {
    # Since today at 00:00 UTC.
    TODAY
    # Since the latest Monday at 00:00 UTC.
    THIS_WEEK
    # Since the first day of the current month at 00:00 UTC.
    THIS_MONTH
    # All time.
    ALL_TIME
}

# SiteUsageStatistics describes a site's aggregate usage statistics.
#
# This information is visible to all viewers.
type SiteUsageStatistics {
    # Recent daily active users.
    daus: [SiteUsagePeriod!]!
    # Recent weekly active users.
    waus: [SiteUsagePeriod!]!
    # Recent monthly active users.
    maus: [SiteUsagePeriod!]!
}

# SiteUsagePeriod describes a site's usage statistics for a given timespan.
#
# This information is visible to all viewers.
type SiteUsagePeriod {
    # The time when this started.
    startTime: String!
    # The user count.
    userCount: Int!
    # The registered user count.
    registeredUserCount: Int!
    # The anonymous user count.
    anonymousUserCount: Int!
    # The count of registered users that have been active on a code host integration.
    # Excludes anonymous users.
    integrationUserCount: Int!
    # The user count of Sourcegraph products at each stage of the software development lifecycle.
    stages: SiteUsageStages
}

# Aggregate site usage of features by software development lifecycle stage.
type SiteUsageStages {
    # The number of users using management stage features.
    manage: Int!
    # The number of users using planning stage features.
    plan: Int!
    # The number of users using coding stage features.
    code: Int!
    # The number of users using review stage features.
    review: Int!
    # The number of users using verification stage features.
    verify: Int!
    # The number of users using packaging stage features.
    package: Int!
    # The number of users using deployment stage features.
    deploy: Int!
    # The number of users using configuration stage features.
    configure: Int!
    # The number of users using monitoring stage features.
    monitor: Int!
    # The number of users using security stage features.
    secure: Int!
    # The number of users using automation stage features.
    automate: Int!
}

# A deployment configuration.
type DeploymentConfiguration {
    # The email.
    email: String
    # The site ID.
    siteID: String
}

# Monitoring overview.
type MonitoringStatistics {
    # Alerts fired in this time span.
    alerts: [MonitoringAlert!]!
}

# A high-level monitoring alert, for details see https://docs.sourcegraph.com/admin/observability/metrics_guide#high-level-alerting-metrics
type MonitoringAlert {
    # End time of this event, which describes the past 12h of recorded data.
    timestamp: DateTime!
    # Name of alert that the service fired.
    name: String!
    # Name of the service that fired the alert.
    serviceName: String!
    # Average percentage of time (between [0, 1]) that the event was firing over the 12h of recorded data. e.g.
    # 1.0 if it was firing 100% of the time on average during that 12h window, 0.5 if it was firing 50% of the
    # time on average, etc.
    average: Float!
}

# A list of survey responses
type SurveyResponseConnection {
    # A list of survey responses.
    nodes: [SurveyResponse!]!
    # The total count of survey responses in the connection. This total count may be larger
    # than the number of nodes in this object when the result is paginated.
    totalCount: Int!
    # The count of survey responses submitted since 30 calendar days ago at 00:00 UTC.
    last30DaysCount: Int!
    # The average score of survey responses in the connection submitted since 30 calendar days ago at 00:00 UTC.
    averageScore: Float!
    # The net promoter score (NPS) of survey responses in the connection submitted since 30 calendar days ago at 00:00 UTC.
    # Return value is a signed integer, scaled from -100 (all detractors) to +100 (all promoters).
    #
    # See https://en.wikipedia.org/wiki/Net_Promoter for explanation.
    netPromoterScore: Int!
}

# An individual response to a user satisfaction (NPS) survey.
type SurveyResponse {
    # The unique ID of the survey response
    id: ID!
    # The user who submitted the survey (if they were authenticated at the time).
    user: User
    # The email that the user manually entered (if they were NOT authenticated at the time).
    email: String
    # User's likelihood of recommending Sourcegraph to a friend, from 0-10.
    score: Int!
    # The answer to "What is the most important reason for the score you gave".
    reason: String
    # The answer to "What can Sourcegraph do to provide a better product"
    better: String
    # The time when this response was created.
    createdAt: DateTime!
}

# Information about this site's product subscription (which enables access to and renewals of a product license).
type ProductSubscriptionStatus {
    # The full name of the product in use, such as "Sourcegraph Enterprise".
    productNameWithBrand: String!
    # The max number of user accounts that have been active on this Sourcegraph site for the current license.
    # If no license is in use, returns zero.
    actualUserCount: Int!
    # The date and time when the max number of user accounts that have been active on this Sourcegraph site for
    # the current license was reached. If no license is in use, returns an empty string.
    actualUserCountDate: String!
    # The number of users allowed. If there is a license, this is equal to ProductLicenseInfo.userCount. Otherwise,
    # it is the user limit for instances without a license, or null if there is no limit.
    maximumAllowedUserCount: Int
    # The number of free users allowed on a site without a license before a warning is shown to all users, or null
    # if a valid license is in use.
    noLicenseWarningUserCount: Int
    # The product license associated with this subscription, if any.
    license: ProductLicenseInfo
}

# Information about this site's product license (which activates certain Sourcegraph features).
type ProductLicenseInfo {
    # The full name of the product that this license is for. To get the product name for the current
    # Sourcegraph site, use ProductSubscriptionStatus.productNameWithBrand instead (to handle cases where there is
    # no license).
    productNameWithBrand: String!
    # Tags indicating the product plan and features activated by this license.
    tags: [String!]!
    # The number of users allowed by this license.
    userCount: Int!
    # The date when this license expires.
    expiresAt: DateTime!
}

# An extension registry.
type ExtensionRegistry {
    # Find an extension by its extension ID (which is the concatenation of the publisher name, a slash ("/"), and the
    # extension name).
    #
    # To find an extension by its GraphQL ID, use Query.node.
    extension(extensionID: String!): RegistryExtension
    # A list of extensions published in the extension registry.
    extensions(
        # Returns the first n extensions from the list.
        first: Int
        # Returns only extensions from this publisher.
        publisher: ID
        # Returns only extensions matching the query.
        #
        # The following keywords are supported:
        #
        # - category:"C" - include only extensions in the given category.
        # - tag:"T" - include only extensions in the given tag.
        #
        # The following keywords are ignored by the server (so that the frontend can post-process the result set to
        # implement the keywords):
        #
        # - #installed - include only installed extensions.
        # - #enabled - include only enabled extensions.
        # - #disabled - include only disabled extensions.
        query: String
        # Include extensions from the local registry.
        local: Boolean = true
        # Include extensions from remote registries.
        remote: Boolean = true
        # Sorts the list of extension results such that the extensions with these IDs are first in the result set.
        #
        # Typically, the client passes the list of added and enabled extension IDs in this parameter so that the
        # results include those extensions first (which is typically what the user prefers).
        prioritizeExtensionIDs: [String!]
    ): RegistryExtensionConnection!
    # A list of publishers with at least 1 extension in the registry.
    publishers(
        # Return the first n publishers from the list.
        first: Int
    ): RegistryPublisherConnection!
    # A list of publishers that the viewer may publish extensions as.
    viewerPublishers: [RegistryPublisher!]!
    # The extension ID prefix for extensions that are published in the local extension registry. This is the
    # hostname (and port, if non-default HTTP/HTTPS) of the Sourcegraph "externalURL" site configuration property.
    #
    # It is null if extensions published on this Sourcegraph site do not have an extension ID prefix.
    #
    # Examples: "sourcegraph.example.com/", "sourcegraph.example.com:1234/"
    localExtensionIDPrefix: String
}

# A publisher of a registry extension.
union RegistryPublisher = User | Org

# A list of publishers of extensions in the registry.
type RegistryPublisherConnection {
    # A list of publishers.
    nodes: [RegistryPublisher!]!
    # The total count of publishers in the connection. This total count may be larger than the number of
    # nodes in this object when the result is paginated.
    totalCount: Int!
    # Pagination information.
    pageInfo: PageInfo!
}

# Mutations for the extension registry.
type ExtensionRegistryMutation {
    # Create a new extension in the extension registry.
    createExtension(
        # The ID of the extension's publisher (a user or organization).
        publisher: ID!
        # The name of the extension.
        name: String!
    ): ExtensionRegistryCreateExtensionResult!
    # Update an extension in the extension registry.
    #
    # Only authorized extension publishers may perform this mutation.
    updateExtension(
        # The extension to update.
        extension: ID!
        # The new name for the extension, or null to leave unchanged.
        name: String
    ): ExtensionRegistryUpdateExtensionResult!
    # Delete an extension from the extension registry.
    #
    # Only authorized extension publishers may perform this mutation.
    deleteExtension(
        # The ID of the extension to delete.
        extension: ID!
    ): EmptyResponse!
    # Publish an extension in the extension registry, creating it (if it doesn't yet exist) or updating it (if it
    # does).
    #
    # This is a helper that wraps multiple other GraphQL mutations to expose a single API for publishing an
    # extension.
    publishExtension(
        # The extension ID of the extension to publish. If a host prefix (e.g., "sourcegraph.example.com/") is
        # needed and it is not included, it is automatically prepended.
        #
        # Examples: "alice/myextension", "acmecorp/myextension"
        extensionID: String!
        # The extension manifest (as JSON).
        manifest: String!
        # The bundled JavaScript source of the extension.
        bundle: String
        # The source map of the extension's JavaScript bundle, if any.
        #
        # The JavaScript bundle's "//# sourceMappingURL=" directive, if any, is ignored. When the bundle is served,
        # the source map provided here is referenced instead.
        sourceMap: String
        # Force publish even if there are warnings (such as invalid JSON warnings).
        force: Boolean = false
    ): ExtensionRegistryCreateExtensionResult!
}

# The result of Mutation.extensionRegistry.createExtension.
type ExtensionRegistryCreateExtensionResult {
    # The newly created extension.
    extension: RegistryExtension!
}

# The result of Mutation.extensionRegistry.updateExtension.
type ExtensionRegistryUpdateExtensionResult {
    # The newly updated extension.
    extension: RegistryExtension!
}

# The result of Mutation.extensionRegistry.publishExtension.
type ExtensionRegistryPublishExtensionResult {
    # The extension that was just published.
    extension: RegistryExtension!
}

# An extension's listing in the extension registry.
type RegistryExtension implements Node {
    # The unique, opaque, permanent ID of the extension. Do not display this ID to the user; display
    # RegistryExtension.extensionID instead (it is friendlier and still unique, but it can be renamed).
    id: ID!
    # The UUID of the extension. This identifies the extension externally (along with the origin). The UUID maps
    # 1-to-1 to RegistryExtension.id.
    uuid: String!
    # The publisher of the extension. If this extension is from a remote registry, the publisher may be null.
    publisher: RegistryPublisher
    # The qualified, unique name that refers to this extension, consisting of the registry name (if non-default),
    # publisher's name, and the extension's name, all joined by "/" (for example, "acme-corp/my-extension-name").
    extensionID: String!
    # The extension ID without the registry name.
    extensionIDWithoutRegistry: String!
    # The name of the extension (not including the publisher's name).
    name: String!
    # The extension manifest, or null if none is set.
    manifest: ExtensionManifest
    # The date when this extension was created on the registry.
    createdAt: DateTime
    # The date when this extension was last updated on the registry (including updates to its metadata only, not
    # publishing new releases).
    updatedAt: DateTime
    # The date when a release of this extension was most recently published, or null if there are no releases.
    publishedAt: DateTime
    # The URL to the extension on this Sourcegraph site.
    url: String!
    # The URL to the extension on the extension registry where it lives (if this is a remote
    # extension). If this extension is local, then this field's value is null.
    remoteURL: String
    # The name of this extension's registry.
    registryName: String!
    # Whether the registry extension is published on this Sourcegraph site.
    isLocal: Boolean!
    # Whether the extension is marked as a work-in-progress extension by the extension author.
    isWorkInProgress: Boolean!
    # Whether the viewer has admin privileges on this registry extension.
    viewerCanAdminister: Boolean!
}

# A description of the extension, how to run or access it, and when to activate it.
type ExtensionManifest {
    # The raw JSON contents of the manifest.
    raw: String!
    # The description specified in the manifest, if any.
    description: String
    # The URL to the bundled JavaScript source code for the extension, if any.
    bundleURL: String
}

# A list of registry extensions.
type RegistryExtensionConnection {
    # A list of registry extensions.
    nodes: [RegistryExtension!]!
    # The total count of registry extensions in the connection. This total count may be larger than the number of
    # nodes in this object when the result is paginated.
    totalCount: Int!
    # Pagination information.
    pageInfo: PageInfo!
    # The URL to this list, or null if none exists.
    url: String
    # Errors that occurred while communicating with remote registries to obtain the list of extensions.
    #
    # In order to be able to return local extensions even when the remote registry is unreachable, errors are
    # recorded here instead of in the top-level GraphQL errors list.
    error: String
}

# Aggregate local code intelligence for all ranges that fall bewteen a window of lines in a document.
type CodeIntelligenceRangeConnection {
    # Aggregate local code intelligence grouped by range.
    nodes: [CodeIntelligenceRange!]!
}

# Aggregate code intelligence for a particular range within a document.
type CodeIntelligenceRange {
    # The range this code intelligence applies to.
    range: Range!

    # A list of definitions of the symbol occurring within the range.
    definitions: LocationConnection!

    # A list of references of the symbol occurring within the range.
    references: LocationConnection!

    # The hover result of the symbol occurring within the range.
    hover: Hover
}

# A list of locations within a file.
type LocationConnection {
    # A list of locations within a file.
    nodes: [Location!]!

    # Pagination information.
    pageInfo: PageInfo!
}

# Hover range and markdown content.
type Hover {
    # A markdown string containing the contents of the hover.
    markdown: Markdown!

    # The range to highlight.
    range: Range!
}

# The state an LSIF upload can be in.
enum LSIFUploadState {
    # This upload is being processed.
    PROCESSING

    # This upload failed to be processed.
    ERRORED

    # This upload was processed successfully.
    COMPLETED

    # This upload is queued to be processed later.
    QUEUED

    # This upload is currently being transferred to Sourcegraph.
    UPLOADING
}

# Metadata and status about an LSIF upload.
type LSIFUpload implements Node {
    # The ID.
    id: ID!

    # The project for which this upload provides code intelligence.
    projectRoot: GitTree

    # The original 40-character commit commit supplied at upload time.
    inputCommit: String!

    # The original root supplied at upload time.
    inputRoot: String!

    # The original indexer name supplied at upload time.
    inputIndexer: String!

    # The upload's current state.
    state: LSIFUploadState!

    # The time the upload was uploaded.
    uploadedAt: DateTime!

    # The time the upload was processed.
    startedAt: DateTime

    # The time the upload compelted or errored.
    finishedAt: DateTime

    # The processing error message (not set if state is not ERRORED).
    failure: String

    # Whether or not this upload provides intelligence for the tip of the default branch. Find reference
    # queries will return symbols from remote repositories only when this property is true. This property
    # is updated asynchronously and is eventually consistent with the git data known by the Sourcegraph
    # instance.
    isLatestForRepo: Boolean!

    # The rank of this upload in the queue. The value of this field is null if the upload has been processed.
    placeInQueue: Int
}

# A list of LSIF uploads.
type LSIFUploadConnection {
    # A list of LSIF uploads.
    nodes: [LSIFUpload!]!

    # The total number of uploads in this result set.
    totalCount: Int

    # Pagination information.
    pageInfo: PageInfo!
}

# The state an LSIF index can be in.
enum LSIFIndexState {
    # This index is being processed.
    PROCESSING

    # This index failed to be processed.
    ERRORED

    # This index was processed successfully.
    COMPLETED

    # This index is queued to be processed later.
    QUEUED
}

# Metadata and status about an LSIF index.
type LSIFIndex implements Node {
    # The ID.
    id: ID!

    # The project for which this upload provides code intelligence.
    projectRoot: GitTree

    # The original 40-character commit commit supplied at index time.
    inputCommit: String!

    # The index's current state.
    state: LSIFIndexState!

    # The time the index was queued.
    queuedAt: DateTime!

    # The time the index was processed.
    startedAt: DateTime

    # The time the index compelted or errored.
    finishedAt: DateTime

    # The processing error message (not set if state is not ERRORED).
    failure: String

    # The rank of this index in the queue. The value of this field is null if the index has been processed.
    placeInQueue: Int
}

# A list of LSIF indexes.
type LSIFIndexConnection {
    # A list of LSIF indexes.
    nodes: [LSIFIndex!]!

    # The total number of indexes in this result set.
    totalCount: Int

    # Pagination information.
    pageInfo: PageInfo!
}

# Mutations that are only used on Sourcegraph.com.
#
# FOR INTERNAL USE ONLY.
type DotcomMutation {
    # Set or unset a user's associated billing information.
    #
    # Only Sourcegraph.com site admins may perform this mutation.
    #
    # FOR INTERNAL USE ONLY.
    setUserBilling(
        # The user to update.
        user: ID!
        # The billing customer ID (on the billing system) to associate this user with. If null, the association is
        # removed (i.e., the user is unlinked from the billing customer record).
        billingCustomerID: String
    ): EmptyResponse!
    # Creates new product subscription for an account.
    #
    # Only Sourcegraph.com site admins may perform this mutation.
    #
    # FOR INTERNAL USE ONLY.
    createProductSubscription(
        # The ID of the user (i.e., customer) to whom this product subscription is assigned.
        accountID: ID!
    ): ProductSubscription!
    # Set or unset a product subscription's associated billing system subscription.
    #
    # Only Sourcegraph.com site admins may perform this mutation.
    #
    # FOR INTERNAL USE ONLY.
    setProductSubscriptionBilling(
        # The product subscription to update.
        id: ID!
        # The billing subscription ID (on the billing system) to associate this product subscription with. If null,
        # the association is removed (i.e., the subscription is unlinked from billing).
        billingSubscriptionID: String
    ): EmptyResponse!
    # Generates and signs a new product license and associates it with an existing product subscription. The
    # product license key is signed with Sourcegraph.com's private key and is verifiable with the corresponding
    # public key.
    #
    # Only Sourcegraph.com site admins may perform this mutation.
    #
    # FOR INTERNAL USE ONLY.
    generateProductLicenseForSubscription(
        # The product subscription to associate with the license.
        productSubscriptionID: ID!
        # The license to generate.
        license: ProductLicenseInput!
    ): ProductLicense!
    # Creates a new product subscription and bills the associated payment method.
    #
    # Only Sourcegraph.com authenticated users may perform this mutation.
    #
    # FOR INTERNAL USE ONLY.
    createPaidProductSubscription(
        # The ID of the user (i.e., customer) to whom the product subscription is assigned.
        #
        # Only Sourcegraph.com site admins may perform this mutation for an accountID != the user ID of the
        # authenticated user.
        accountID: ID!
        # The details of the product subscription.
        productSubscription: ProductSubscriptionInput!
        # The token that represents the payment method used to purchase this product subscription,
        # or null if no payment is required.
        paymentToken: String
    ): CreatePaidProductSubscriptionResult!
    # Updates a new product subscription and credits or debits the associated payment method.
    #
    # Only Sourcegraph.com site admins and the subscription's account owner may perform this
    # mutation.
    #
    # FOR INTERNAL USE ONLY.
    updatePaidProductSubscription(
        # The subscription to update.
        subscriptionID: ID!
        # The updated details of the product subscription. All fields of the input type must be set
        # (i.e., it does not support passing a null value to mean "do not update this field's
        # value").
        update: ProductSubscriptionInput!
        # The token that represents the payment method used to pay for (or receive credit for) this
        # product subscription update, or null if no payment is required.
        paymentToken: String
    ): UpdatePaidProductSubscriptionResult!
    # Archives an existing product subscription.
    #
    # Only Sourcegraph.com site admins may perform this mutation.
    #
    # FOR INTERNAL USE ONLY.
    archiveProductSubscription(id: ID!): EmptyResponse!
}

# Mutations that are only used on Sourcegraph.com.
#
# FOR INTERNAL USE ONLY.
type DotcomQuery {
    # The product subscription with the given UUID. An error is returned if no such product
    # subscription exists.
    #
    # Only Sourcegraph.com site admins and the account owners of the product subscription may
    # perform this query.
    #
    # FOR INTERNAL USE ONLY.
    productSubscription(uuid: String!): ProductSubscription!
    # A list of product subscriptions.
    #
    # FOR INTERNAL USE ONLY.
    productSubscriptions(
        # Returns the first n product subscriptions from the list.
        first: Int
        # Returns only product subscriptions for the given account.
        #
        # Only Sourcegraph.com site admins may perform this query with account == null.
        account: ID
        # Returns product subscriptions from users with usernames or email addresses that match the query.
        query: String
    ): ProductSubscriptionConnection!
    # The invoice that would be generated for a new or updated subscription. This is used to show
    # users a preview of the credits, debits, and other billing information before creating or
    # updating a subscription.
    #
    # Performing this query does not mutate any data or cause any billing changes to be made.
    previewProductSubscriptionInvoice(
        # The customer account (user) for whom this preview invoice will be generated, or null if there is none.
        account: ID
        # If non-null, preview the invoice for an update to the existing product subscription. The
        # product subscription's billing customer must match the account parameter. If null, preview
        # the invoice for a new subscription.
        subscriptionToUpdate: ID
        # The parameters for the product subscription to preview. All fields of the input type must
        # be set (i.e., it does not support passing a null value to mean "do not update this field's
        # value" when updating an existing subscription).
        productSubscription: ProductSubscriptionInput!
    ): ProductSubscriptionPreviewInvoice!
    # A list of product licenses.
    #
    # Only Sourcegraph.com site admins may perform this query.
    #
    # FOR INTERNAL USE ONLY.
    productLicenses(
        # Returns the first n product subscriptions from the list.
        first: Int
        # Returns only product subscriptions whose license key contains this substring.
        licenseKeySubstring: String
        # Returns only product licenses associated with the given subscription
        productSubscriptionID: ID
    ): ProductLicenseConnection!
    # A list of product pricing plans for Sourcegraph.
    productPlans: [ProductPlan!]!
}

# A product subscription that was created on Sourcegraph.com.
#
# FOR INTERNAL USE ONLY.
type ProductSubscription implements Node {
    # The unique ID of this product subscription.
    id: ID!
    # The unique UUID of this product subscription. Unlike ProductSubscription.id, this does not
    # encode the type and is not a GraphQL node ID.
    uuid: String!
    # A name for the product subscription derived from its ID. The name is not guaranteed to be unique.
    name: String!
    # The user (i.e., customer) to whom this subscription is granted, or null if the account has been deleted.
    account: User
    # The information that determines the price of this subscription, or null if there is no billing
    # information associated with this subscription.
    invoiceItem: ProductSubscriptionInvoiceItem
    # A list of billing-related events related to this product subscription.
    events: [ProductSubscriptionEvent!]!
    # The currently active product license associated with this product subscription, if any.
    activeLicense: ProductLicense
    # A list of product licenses associated with this product subscription.
    #
    # Only Sourcegraph.com site admins may list inactive product licenses (other viewers should use
    # ProductSubscription.activeLicense).
    productLicenses(
        # Returns the first n product licenses from the list.
        first: Int
    ): ProductLicenseConnection!
    # The date when this product subscription was created.
    createdAt: DateTime!
    # Whether this product subscription was archived.
    isArchived: Boolean!
    # The URL to view this product subscription.
    url: String!
    # The URL to view this product subscription in the site admin area.
    #
    # Only Sourcegraph.com site admins may query this field.
    urlForSiteAdmin: String
    # The URL to view this product subscription's billing information (for site admins).
    #
    # Only Sourcegraph.com site admins may query this field.
    urlForSiteAdminBilling: String
}

# A list of product subscriptions.
#
# FOR INTERNAL USE ONLY.
type ProductSubscriptionConnection {
    # A list of product subscriptions.
    nodes: [ProductSubscription!]!
    # The total count of product subscriptions in the connection. This total count may be larger than the number of
    # nodes in this object when the result is paginated.
    totalCount: Int!
    # Pagination information.
    pageInfo: PageInfo!
}

# A preview of an invoice that would be generated for a new or updated product subscription.
#
# FOR INTERNAL USE ONLY.
type ProductSubscriptionPreviewInvoice {
    # The net price for this invoice, in USD cents. If this invoice represents an update to a
    # subscription, this is the difference between the existing price and the updated price.
    price: Int!
    # For updates to existing subscriptions, the effective date for which this preview invoice was
    # calculated, expressed as the number of seconds since the epoch. For new subscriptions, this is
    # null.
    prorationDate: String
    # Whether this invoice requires manual intervention.
    isDowngradeRequiringManualIntervention: Boolean!
    # The "before" state of the product subscription (i.e., the existing subscription), prior to the update that this preview
    # represents, or null if the preview is for a new subscription.
    beforeInvoiceItem: ProductSubscriptionInvoiceItem
    # The "after" state of the product subscription, with the update applied to the subscription.
    # For new subscriptions, this is just the invoice item for the subscription that will be
    # created.
    afterInvoiceItem: ProductSubscriptionInvoiceItem!
}

# An input type that describes a product license to be generated and signed.
#
# FOR INTERNAL USE ONLY.
input ProductLicenseInput {
    # The tags that indicate which features are activated by this license.
    tags: [String!]!
    # The number of users for which this product subscription is valid.
    userCount: Int!
    # The expiration date of this product license, expressed as the number of seconds since the epoch.
    expiresAt: Int!
}

# A product license that was created on Sourcegraph.com.
#
# FOR INTERNAL USE ONLY.
type ProductLicense implements Node {
    # The unique ID of this product license.
    id: ID!
    # The product subscription associated with this product license.
    subscription: ProductSubscription!
    # Information about this product license.
    info: ProductLicenseInfo
    # The license key.
    licenseKey: String!
    # The date when this product license was created.
    createdAt: DateTime!
}

# A list of product licenses.
#
# FOR INTERNAL USE ONLY.
type ProductLicenseConnection {
    # A list of product licenses.
    nodes: [ProductLicense!]!
    # The total count of product licenses in the connection. This total count may be larger than the number of
    # nodes in this object when the result is paginated.
    totalCount: Int!
    # Pagination information.
    pageInfo: PageInfo!
}

# A product pricing plan for Sourcegraph.
#
# FOR INTERNAL USE ONLY.
type ProductPlan {
    # The billing system's unique ID for the plan.
    billingPlanID: String!
    # The unique ID for the product.
    productPlanID: String!
    # The name of the product plan (e.g., "Enterprise Starter"). This is displayed to the user and
    # should be human-readable.
    name: String!
    # The name with the brand (e.g., "Sourcegraph Enterprise Starter").
    nameWithBrand: String!
    # The price (in USD cents) for one user for a year.
    pricePerUserPerYear: Int!
    # The minimum quantity (user count) that can be purchased. Only applies when using tiered pricing.
    minQuantity: Int
    # The maximum quantity (user count) that can be purchased. Only applies when using tiered pricing.
    maxQuantity: Int
    # Defines if the tiering price should be graduated or volume based.
    tiersMode: String!
    # The tiered pricing for the plan.
    planTiers: [PlanTier!]!
}

# The information about a plan's tier.
#
# FOR INTERNAL USE ONLY.
type PlanTier {
    # The per-user amount for this tier.
    unitAmount: Int!
    # The maximum number of users that this tier applies to.
    upTo: Int!
    # The flat fee for this tier.
    flatAmount: Int!
}

# The information about a product subscription that determines its price.
#
# FOR INTERNAL USE ONLY.
type ProductSubscriptionInvoiceItem {
    # The product plan for the subscription.
    plan: ProductPlan!
    # This subscription's user count.
    userCount: Int!
    # The date when the subscription expires.
    expiresAt: DateTime!
}

# An input type that describes a product subscription to be purchased. Corresponds to
# ProductSubscriptionInvoiceItem.
#
# FOR INTERNAL USE ONLY.
input ProductSubscriptionInput {
    # The billing plan ID for the subscription (ProductPlan.billingPlanID). This also specifies the
    # billing product, because a plan is associated with its product in the billing system.
    billingPlanID: String!
    # This subscription's user count.
    userCount: Int!
}

# The result of Mutation.dotcom.createPaidProductSubscription.
#
# FOR INTERNAL USE ONLY.
type CreatePaidProductSubscriptionResult {
    # The newly created product subscription.
    productSubscription: ProductSubscription!
}

# The result of Mutation.dotcom.updatePaidProductSubscription.
#
# FOR INTERNAL USE ONLY.
type UpdatePaidProductSubscriptionResult {
    # The updated product subscription.
    productSubscription: ProductSubscription!
}

# An event related to a product subscription.
#
# FOR INTERNAL USE ONLY.
type ProductSubscriptionEvent {
    # The unique ID of the event.
    id: String!
    # The date when the event occurred.
    date: String!
    # The title of the event.
    title: String!
    # A description of the event.
    description: String
    # A URL where the user can see more information about the event.
    url: String
}

# FOR INTERNAL USE ONLY: A status message produced when repositories are being
# cloned
type CloningProgress {
    # The message of this status message
    message: String!
}

# FOR INTERNAL USE ONLY: A status message produced when repositories could not
# be synced from an external service
type ExternalServiceSyncError {
    # The message of this status message
    message: String!
    # The external service that failed to sync
    externalService: ExternalService!
}

# FOR INTERNAL USE ONLY: A status message produced when repositories could not
# be synced
type SyncError {
    # The message of this status message
    message: String!
}

# FOR INTERNAL USE ONLY: A status message
union StatusMessage = CloningProgress | ExternalServiceSyncError | SyncError

# An RFC 3339-encoded UTC date string, such as 1973-11-29T21:33:09Z. This value can be parsed into a
# JavaScript Date using Date.parse. To produce this value from a JavaScript Date instance, use
# Date#toISOString.
scalar DateTime

# Different repository permission levels.
enum RepositoryPermission {
    READ
}

# A single user event that has been logged.
type EventLog {
    # The name of the event.
    name: String!
    # The user who executed the event, if one exists.
    user: User
    # The randomly generated unique user ID stored in a browser cookie.
    anonymousUserID: String!
    # The URL when the event was logged.
    url: String!
    # The source of the event.
    source: EventSource!
    # The additional argument information.
    argument: String
    # The Sourcegraph version when the event was logged.
    version: String!
    # The timestamp when the event was logged.
    timestamp: DateTime!
}

# A list of event logs.
type EventLogsConnection {
    # A list of event logs.
    nodes: [EventLog!]!
    # The total count of event logs in the connection. This total count may be larger than the number of nodes
    # in this object when the result is paginated.
    totalCount: Int!
    # Pagination information.
    pageInfo: PageInfo!
}
